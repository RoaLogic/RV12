\chapter{Control and Status Registers} \label{control-and-status-registers}

\section{Introduction}\label{introduction-3}

The state of the CPU is maintained by the Control \& Status Registers
(CSRs). They determine the feature set, set interrupts and interrupt
masks, and determine the privilege level. The CSRs are mapped into an
internal 12bit address space and are accessible using special commands.

\section{Accessing the CSRs}\label{accessing-the-csrs}

\ifdefined\MARKDOWN
% Exclude Table
\else

\begin{figure*}[htb]
\begin{center}
	\begin{tabular}{M@{}R@{}F@{}R@{}S}
		\\
		\instbitrange{31}{20} &
		\instbitrange{19}{15} &
		\instbitrange{14}{12} &
		\instbitrange{11}{7} &
		\instbitrange{6}{0} \\
		\hline
		\multicolumn{1}{|c|}{csr} &
		\multicolumn{1}{c|}{rs1} &
		\multicolumn{1}{c|}{funct3} &
		\multicolumn{1}{c|}{rd} &
		\multicolumn{1}{c|}{opcode} \\
		\hline
		12 & 5 & 3 & 5 & 7 \\
		source/dest  & source & CSRRW  & dest & SYSTEM \\
		source/dest  & source & CSRRS  & dest & SYSTEM \\
		source/dest  & source & CSRRC  & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRWI & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRSI & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRCI & dest & SYSTEM \\
	\end{tabular}
\end{center}
\caption{CSR Instructions}
\end{figure*}

\fi

The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values in
the CSRs and integer registers. CSRRW reads the old value of the CSR,
zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} is written to the
CSR.

The CSRRS (Atomic Read and Set CSR) instruction reads the old value of
the CSR, zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} specifies the bit
positions to be set in the CSR. Any bit that is high in \emph{rs1} will
be set in the CSR, assuming that bit can be set. The effect is a logic
OR between the old value in the CSR and the new value in \emph{rs1}.

If \emph{rs1}=X0, then the CSR is not written to.

The CSRRC (Atomic Read and Clear CSR) instruction reads the old value of
the CSR, zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} specifies the bit
positions to be cleared in the CSR. Any bit that is high in \emph{rs1}
will be cleared in the CSR, assuming that bit can be cleared. If
\emph{rs1}=X0, then the CSR is not written to.

The CSRRWI, CSRRSI, and CSRRCI commands are similar in behavior. Except
that they update the CSR using an immediate value, instead of
referencing a source register. The immediate value is obtained by
zero-extending the 5bit \emph{zimm} field. If \emph{zimm[4:0]} is
zero, then the CSR is not written to.

\section{Illegal CSR accesses}\label{illegal-csr-accesses}

Depending on the privilege level some CSRs may not be accessible.
Attempts to access a non-existing CSR raise an illegal-instruction
exception. Attempts to access a privileged CSR or write a read-only CSR
raise an illegal-instruction exception. Machine Mode can access all
CSRs, whereas User Mode can only access a
few.

\section{Timers and Counters}\label{timers-and-counters}

\ifdefined\MARKDOWN
% Exclude Table
\else

\begin{figure*}
	\begin{center}
		\begin{tabular}{M@{}R@{}F@{}R@{}S}
			\\
			\instbitrange{31}{20} &
			\instbitrange{19}{15} &
			\instbitrange{14}{12} &
			\instbitrange{11}{7} &
			\instbitrange{6}{0} \\
			\hline
			\multicolumn{1}{|c|}{csr} &
			\multicolumn{1}{c|}{rs1} &
			\multicolumn{1}{c|}{funct3} &
			\multicolumn{1}{c|}{rd} &
			\multicolumn{1}{c|}{opcode} \\
			\hline
			12 & 5 & 3 & 5 & 7 \\
			RDCYCLE[H]   & 0 & CSRRS  & dest & SYSTEM \\
			RDTIME[H]    & 0 & CSRRS  & dest & SYSTEM \\
			RDINSTRET[H] & 0 & CSRRS  & dest & SYSTEM \\
		\end{tabular}
	\end{center}
	\caption{Time \& Counter Instructions}
\end{figure*}

\fi

The RV12 provides a number of 64-bit read-only user-level counters,
which are mapped into the 12-bit CSR address space and accessed in
32-bit pieces using CSRRS instructions.

The RDCYCLE pseudo-instruction reads the low XLEN bits of the cycle CSR
that holds a count of the number of clock cycles executed by the
processor on which the hardware thread is running from an arbitrary
start time in the past. RDCYCLEH is an RV32I-only instruction that reads
bits 63--32 of the same cycle counter. The rate at which the cycle
counter advances will depend on the implementation and operating
environment.

The RDTIME pseudo-instruction reads the low XLEN bits of the time CSR,
which counts wall-clock real time that has passed from an arbitrary
start time in the past. RDTIMEH is an RV32I-only instruction that reads
bits 63--32 of the same real-time counter. The underlying 64-bit counter
should never overflow in practice. The execution environment should
provide a means of determining the period of the real-time counter
(seconds/tick). The period must be constant. The real-time clocks of all
hardware threads in a single user application should be synchronized to
within one tick of the real-time clock. The environment should provide a
means to determine the accuracy of the clock.

The RDINSTRET pseudo-instruction reads the low XLEN bits of the instret
CSR, which counts the number of instructions retired by this hardware
thread from some arbitrary start point in the past. RDINSTRETH is an
RV32I-only instruction that reads bits 63--32 of the same instruction
counter.

In RV64I, the CSR instructions can manipulate 64-bit CSRs. In
particular, the RDCYCLE, RDTIME, and RDINSTRET pseudo-instructions read
the full 64 bits of the cycle, time, and instret counters. Hence, the
RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are not necessary and are
illegal in RV64I.

\section{CSR Listing}\label{csr-listing}

The following sections describe each of the register functions as
specifically implemented in RV12.

Note: These descriptions are derived from ``The RISC-V Instruction Set
Manual, Volume II: Privileged Architecture, Version 1.10", Editors
Andrew Waterman and Krste AsanoviÄ‡, RISC-V Foundation, May 7, 2017,
and released under the Creative Commons Attribution 4.0 International
License

\begin{longtable}[]{@{\extracolsep{\fill}}ccll@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else

	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot

\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Information Registers}}}\tabularnewline
\fi

	0xF11 & MRO & \texttt{mvendorid} & Vendor ID\tabularnewline
	0xF12 & MRO & \texttt{marchid}   & Architecture ID\tabularnewline
	0xF13 & MRO & \texttt{mimpid}    & Implementation ID\tabularnewline
	0xF14 & MRO & \texttt{mhartid}   & Hardware thread ID\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Trap Setup}}}\tabularnewline
\fi

	0x300 & MRW & \texttt{mstatus}    & Machine status register\tabularnewline
	0x301 & MRW & \texttt{misa}       & ISA and extensions\tabularnewline
	0x302 & MRW & \texttt{medeleg}    & Machine exception delegation register\tabularnewline
	0x303 & MRW & \texttt{mideleg}    & Machine interrupt delegation register\tabularnewline
	0x304 & MRW & \texttt{mie}        & Machine interrupt-enable register\tabularnewline
	0x305 & MRW & \texttt{mtvec}      & Machine trap-handler base address\tabularnewline
	0x306 & MRW & \texttt{mcounteren} & Machine counter enable\tabularnewline
	0x7c0 & MRW & \texttt{mnmivec}    & Machine non-maskable interrupt vector\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Trap Handling}}}\tabularnewline
\fi

	0x340 & MRW & \texttt{mscratch} & Scratch register for machine trap handler\tabularnewline
	0x341 & MRW & \texttt{mepc}     & Machine exception program counter\tabularnewline
	0x342 & MRW & \texttt{mcause}   & Machine trap cause\tabularnewline
	0x343 & MRW & \texttt{mtval}    & Machine bad address or instruction\tabularnewline
	0x344 & MRW & \texttt{mip}      & Machine interrupt pending\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Counter/Timers}}}\tabularnewline
\fi

	0xB00 & MRW & \texttt{mcycle}         & Machine cycle counter\tabularnewline
	0xB02 & MRW & \texttt{minstret}       & Machine instructions-retired counter\tabularnewline
	0xB03 & MRW & \texttt{mhpmcounter3}   & Machine performance-monitoring counter\\
	0xB04 & MRW & \texttt{mhpmcounter4}   & Machine performance-monitoring counter\\
	      &     & \vdots                  & \\
	0xB1F & MRW & \texttt{mhpmcounter31}  & Machine performance-monitoring counter\\
	0xB80 & MRW & \texttt{mcycleh}        & Upper 32 bits of \texttt{mcycle}, RV32I only\tabularnewline
	0xB82 & MRW & \texttt{minstreth}      & Upper 32 bits of \texttt{minstret}, RV32I only\tabularnewline
	0xB83 & MRW & \texttt{mhpmcounter3h}  & Upper 32 bits of mhpmcounter3, RV32I only\\
	0xB84 & MRW & \texttt{mhpmcounter4h}  & Upper 32 bits of mhpmcounter4, RV32I only\\
	      &     & \vdots                  & \\
	0xB9F & MRW & \texttt{mhpmcounter31h} & Upper 32 bits of mhpmcounter31, RV32I only\\

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Counter Setup}}}\tabularnewline
\fi

	0x323 & MRW & \texttt{mhpevent3}      & Machine performance-monitoring event selector\\
	0x324 & MRW & \texttt{mhpevent4}      & Machine performance-monitoring event selector\\
	      &     & \vdots                  & \\
	0x33F & MRW & \texttt{mhpevent31}     & Machine performance-monitoring event selector\\

\bottomrule
\caption{Machine Mode CSRs}
\label{tab:machine-csrs}
\end{longtable}

\begin{longtable}[]{@{\extracolsep{\fill}}ccll@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else
	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot
\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Supervisor Trap Handling}}}\tabularnewline
\fi

	0x100 & SRW & \texttt{sstatus}    & Supervisor status register\tabularnewline
	0x102 & SRW & \texttt{sedeleg}    & Supervisor exception delegation register\tabularnewline
	0x103 & SRW & \texttt{sideleg}    & Supervisor interrupt delegation register\tabularnewline
	0x104 & SRW & \texttt{sie}        & Supervisor interrupt-enable register\tabularnewline
	0x105 & SRW & \texttt{stvec}      & Supervisor trap handler base address\tabularnewline
	0x106 & SRW & \texttt{scounteren} & Supervisor counter enable\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Supervisor Trap Handling}}}\tabularnewline

\fi
	0x140 & SRW & \texttt{sscratch} & Scratch register for trap handler\tabularnewline
	0x141 & SRW & \texttt{sepc}     & Supervisor exception program counter\tabularnewline
	0x142 & SRO & \texttt{scause}   & Supervisor trap cause\tabularnewline
	0x143 & SRO & \texttt{sbadaddr} & Supervisor bad address\tabularnewline
	0x144 & SRW & \texttt{sip}      & Supervisor interrupt pending register\tabularnewline

%
% Implemented but currently unused
%
% \ifdefined\MARKDOWN
% % Skip Row
% \else
% 	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Supervisor Protection and Translation}}}\tabularnewline
% \fi

% 	0x180 & SRW & \texttt{satp} & \tabularnewline

	\bottomrule
	\caption{Supervisor Mode CSRs}
	\label{tab:supervisor-csrs}
\end{longtable}


\begin{longtable}[]{@{\extracolsep{\fill}}ccll@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else

	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot
\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{User Trap Setup}}}\tabularnewline
\fi

	0x000 & URW & \texttt{ustatus} & User status register\tabularnewline
	0x004 & URW & \texttt{uie}     & User interrupt-enable register\tabularnewline
	0x005 & URW & \texttt{utvec}   & User trap-handler base address\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{User Trap Handling}}}\tabularnewline
\fi

	0x040 & URW & \texttt{uscratch} & Scratch register for User trap handler\tabularnewline
	0x041 & URW & \texttt{uepc}     & User exception program counter\tabularnewline
	0x042 & URW & \texttt{ucause}   & User trap cause\tabularnewline
	0x043 & URW & \texttt{utval}    & User bad address\tabularnewline
	0x044 & URW & \texttt{uip}      & User interrupt pending\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{User Counter / Timers}}}\tabularnewline
\fi

	0xC00 & URO & \texttt{cycle}         & Cycle counter for \texttt{RDCYCLE} instruction\tabularnewline
	0xC01 & URO & \texttt{time}          & Timer for RDTIME instruction\tabularnewline
	0xC02 & URO & \texttt{instret}       & Instruction-retire counter for \texttt{RDINSTRET}\tabularnewline
	0xC03 & URO & \texttt{hpmcounter3}   & Performance-monitoring counter\tabularnewline
	0xC04 & URO & \texttt{hpmcounter4}   & Performance-monitoring counter\tabularnewline
	      &     & \vdots                 & \tabularnewline
	0xC1F & URO & \texttt{hpmcounter31}  & Performance-monitoring counter\tabularnewline
	0xC80 & URO & \texttt{cycleh}        & Upper 32bits of \texttt{cycle}, RV32I only\tabularnewline
	0xC81 & URO & \texttt{timeh}         & Upper 32bits of \texttt{time}, RV32I only\tabularnewline
	0xC82 & URO & \texttt{instreth}      & Upper 32bit of \texttt{instret}, RV32I only\tabularnewline
	0xC83 & URO & \texttt{hpmcounter3h}  & Upper 32bit of \texttt{hpmcounter3}, RV32I only\tabularnewline
	0xC84 & URO & \texttt{hpmcounter4h}  & Upper 32bit of \texttt{hpmcounter4}, RV32I only\tabularnewline
	      &     & \vdots                 & \tabularnewline
	0xC9F & URO & \texttt{hpmcounter31h} & Upper 32bit of \texttt{hpmcounter31}, RV32I only\tabularnewline
	\bottomrule
	\caption{User Mode CSRs}
	\label{tab:user-csrs}
\end{longtable}

\begin{longtable}[]{@{\extracolsep{\fill}}ccll@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else

	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot
\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Memory Protection Configuration}}}\tabularnewline
\fi

	0x3A0 & MRW & \texttt{pmpcfg0} & Physical memory protection configuration\tabularnewline
	0x3A1 & MRW & \texttt{pmpcfg1} & Physical memory protection configuration, RV32 Only\tabularnewline
	0x3A2 & MRW & \texttt{pmpcfg2} & Physical memory protection configuration\tabularnewline
	0x3A3 & MRW & \texttt{pmpcfg3} & Physical memory protection configuration,RV32 Only\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Memory Protection Addressing}}}\tabularnewline
\fi

	0x3B0 & MRW & \texttt{pmpaddr0}  & Physical memory protection address register\tabularnewline
	0x3B1 & MRW & \texttt{pmpaddr1}  & Physical memory protection address register\tabularnewline
	      &    & \vdots             & \tabularnewline
	0x3BF & MRW & \texttt{pmpaddr15} & Physical memory protection address register\tabularnewline

	\bottomrule
	\caption{Memory Protection CSRs}
	\label{tab:pmp-csrs}
\end{longtable}

\section{Machine Level CSRs}\label{machine-level-csrs}

In addition to the machine-level CSRs described in this section, M-mode
can access all CSRs at lower privilege levels.

\subsection{Machine ISA Register (\texttt{misa})}\label{machine-isa-register-misa}

The \texttt{misa} register is an XLEN-bit WARL read-write register reporting the
ISA supported by the hart.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}c@{}J}
				\instbitrange{XLEN-1}{XLEN-2} &
				\instbitrange{XLEN-3}{26} &
				\instbitrange{25}{0} \\
				\hline
				\multicolumn{1}{|c|}{Base (\warl)} &
				\multicolumn{1}{c|}{\wiri} &
				\multicolumn{1}{c|}{Extensions (\warl)} \\
				\hline
				2 & XLEN-28 & 26 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine ISA register (\texttt{misa}).}
	\label{fig:misareg}
\end{figure*}

\fi

The extensions field encodes the presence of the standard extensions,
with a single bit per letter of the alphabet (bit 0 encodes the presence
of extension ``A'', bit 1 encodes the presence of extension ``B'',
through to bit 25 that encodes the presence of extension ``Z'').

The ``I'' bit will be set for RV32I and RV64I base ISAs, and the ``E''
bit will be set for RV32E.

The Base field encodes the native base integer ISA width as shown:

\begin{longtable}[]{@{}cc@{}}
\toprule
Value & Description\tabularnewline
\midrule
\endhead
1 & 32\tabularnewline
2 & 64\tabularnewline
\bottomrule
\caption{Supported \texttt{misa} values}
\label{tab:misa-values}
\end{longtable}

\subsection{Vendor ID Register (\texttt{mvendorid})}\label{vendor-id-register-mvendorid}

The \texttt{mvendorid} read-only register is an XLEN-bit register encoding the JEDEC manufacturer ID of the provider of the core.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
	\begin{center}
	\begin{tabular}{JS}
	\instbitrange{XLEN-1}{7} &
	\instbitrange{6}{0} \\
	\hline
	\multicolumn{1}{|c|}{Bank} &
	\multicolumn{1}{c|}{Offset} \\
	\hline
	XLEN-7 & 7 \\
	\end{tabular}
	\end{center}
	}	\vspace{-0.1in}
	\caption{Vendor ID register (\texttt{mvendorid}).}
	\label{fig:mvendorreg}
\end{figure*}

\fi

The Roa Logic JEDEC ID is:

\indent\indent\texttt{7F 7F 7F 7F 7F 7F 7F 7F 7F 6E}

This ID is specified via the \texttt{JEDEC\_BANK} and
\texttt{JEDEC\_MANUFACTURER\_ID} configuration parameters

\texttt{mvendorid} encodes the number of one-byte continuation codes of
the \texttt{JEDEC\_BANK} parameter in the Bank field, and encodes the
final \texttt{JEDEC\_MANUFACTURER\_ID} byte in the Offset field,
discarding the parity bit.

For the Roa Logic JEDEC manufacturer ID, this translates as:

\indent\indent\texttt{mvendorid} = \{\texttt{JEDEC\_BANK-1}, \texttt{JEDEC\_MANUFACTURER\_ID[6:0]}\} = 0x4EE

\subsection{Architecture ID Register
(\texttt{marchid})}\label{architecture-id-register-marchid}

The \texttt{marched} CSR is an XLEN-bit read-only register encoding the base
microarchitecture of the hart. For the RV12 CPU this is defined as:

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Architecture ID} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Architecture ID register (\texttt{marchid}).}
	\label{fig:marchreg}
\end{figure*}

\fi

The Architecture ID for the RV12 CPU is defined as 0x12.

Note: Open-source project architecture IDs are allocated globally by the
RISC-V Foundation, and have non-zero architecture IDs with a zero
most-significant-bit (MSB). Commercial architecture IDs are allocated by
each commercial vendor independently and have the MSB set.

\subsection{Implementation ID Register
(\texttt{mimpid})}\label{implementation-id-register-mimpid}

\texttt{mimpid} is an XLEN-sized read-only register provides hardware version
information for the CPU.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Implementation}  \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Implementation ID register (\texttt{mimpid}).}
	\label{fig:mimpidreg}
\end{figure*}

\fi

The RISC-V specification calls for the contents of \texttt{mimpid} to be defined
by the supplier/developer of the CPU core. In the Roa Logic implementation, this
register is used to define the User Specification, Privilege Specification and
Extension Specifications supported by that specific version of the RV12 core.

The value held within the \texttt{mimpid} CSR is an integer denoting
Specification and Extension support as defined in the following table:

\begin{longtable}[]{@{}cccccc@{}}
\toprule
\texttt{mimpid} & User Spec. & Privilege Spec. & A-Ext. & C-Ext. & M-Ext. \\
\midrule
\endhead
0               & v2.2       & v1.10           & v2.0   & --     & v2.0   \\
1               & v2.2       & v1.10           & v2.0   & v1.7   & v2.0   \\
2               & v2.2       & v1.11           & v2.0   & v1.7   & v2.0   \\
\bottomrule
\caption{Supported \texttt{mimpid} values}
\label{tab:mimpid-values}
\end{longtable}



\subsection{Hardware Thread ID Register
(\texttt{mhartid})}\label{hardware-thread-id-register-mhartid}

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Hart ID}\\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Hart ID register (\texttt{mhartid}).}
	\label{fig:mhartidreg}
\end{figure*}

\fi

The \texttt{mhartid} read-only register indicates the hardware thread that is
running the code. The RV12 implements a single thread, therefore this
register always reads zero.

\subsection{Machine Status Register ({\tt mstatus})}

The {\tt mstatus} register is an XLEN-bit read/write register
formatted as shown in Figure~\ref{mstatusreg-rv32} for RV32 and
Figure~\ref{mstatusreg} for RV64.  The {\tt mstatus}
register keeps track of and controls the hart's current operating
state.  Restricted views of the {\tt mstatus} register appear as the
{\tt sstatus} and {\tt ustatus} registers in the S-level and U-level
ISAs respectively.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cKccccccc}
\\
\instbit{31} &
\instbitrange{30}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & 8 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cccccccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbitrange{10}{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV32.}
\label{mstatusreg-rv32}
\end{figure*}

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cYccYccccccc}
\\
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{36} &
\instbitrange{35}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SXL[1:0]} &
\multicolumn{1}{c|}{UXL[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & XLEN-37 & 2 & 2 & 9 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cccccccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbitrange{10}{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV64 and RV128.}
\label{mstatusreg}
\end{figure*}

\fi


\subsection{Privilege and Global Interrupt-Enable Stack in {\tt mstatus} register}
\label{privstack}

Interrupt-enable bits, MIE, SIE, and UIE, are provided for each privilege
mode.  These bits are primarily used to guarantee atomicity with respect to
interrupt handlers at the current privilege level.  When a hart is executing
in privilege mode {\em x}, interrupts are enabled when {\em x}\,IE=1.
Interrupts for lower privilege modes are always disabled, whereas interrupts
for higher privilege modes are always enabled.  Higher-privilege-level code
can use separate per-interrupt enable bits to disable selected interrupts
before ceding control to a lower privilege level.

To support nested traps, each privilege mode {\em x} has a two-level
stack of interrupt-enable bits and privilege modes.  {\em x}\,PIE
holds the value of the interrupt-enable bit active prior to the trap,
and {\em x}\,PP holds the previous privilege mode.  The {\em x}\,PP
fields can only hold privilege modes up to {\em x}, so MPP is
two bits wide, SPP is one bit wide, and UPP is implicitly zero.  When
a trap is taken from privilege mode {\em y} into privilege mode {\em
  x}, {\em x}\,PIE is set to the value of {\em x}\,IE; {\em x}\,IE is set to
0; and {\em x}\,PP is set to {\em y}.

The MRET, SRET, or URET instructions are used to return from
traps in M-mode, S-mode, or U-mode respectively.  When
executing an {\em x}RET instruction, supposing {\em x}\,PP holds the
value {\em y}, {\em x}\,IE is set to {\em x}\,PIE; the privilege mode
is changed to {\em y}; {\em x}\,PIE is set to 1; and {\em x}\,PP is
set to U (or M if user-mode is not supported).

{\em x}\,PP fields are \wlrl\ fields that need only be able to store
supported privilege modes, including {\em x} and any implemented
privilege mode lower than {\em x}.

User-level interrupts are an optional extension and have been
allocated the ISA extension letter N.
If user-level interrupts are omitted, the
UIE and UPIE bits are hardwired to zero.  For all other supported
privilege modes {\em x}, the {\em x}\,IE and {\em x}\,PIE must not
be hardwired.

\subsection{Base ISA Control in {\tt mstatus} Register}

For RV64 systems, the SXL and UXL fields are \warl\ fields
that control the value of XLEN for S-mode and U-mode,
respectively. The encoding of these fields is the same as the MXL
field of {\tt misa}.  The effective
XLEN in S-mode and U-mode are termed {\em S-XLEN} and {\em U-XLEN},
respectively.

For RV32 systems, the SXL and UXL fields do not exist, and
S-XLEN~=~32 and U-XLEN~=~32.

\subsection{Memory Privilege in {\tt mstatus} Register}

The MPRV (Modify PRiVilege) bit modifies the privilege level at which
loads and stores execute in all privilege modes.  When MPRV=0,
translation and protection behave as normal.  When MPRV=1, load and
store memory addresses are translated and protected as though the
current privilege mode were set to MPP.  Instruction
address-translation and protection are unaffected.  MPRV is hardwired
to 0 if U-mode is not supported.

The MXR (Make eXecutable Readable) bit modifies the privilege with which loads
access virtual memory.  When MXR=0, only loads from pages marked readable will
succeed.  When MXR=1, loads from pages marked
either readable or executable (R=1 or X=1) will succeed. MXR is hardwired to 0 if
S-mode is not supported.

The SUM (permit Supervisor User Memory access) bit modifies the privilege with
which S-mode loads, stores, and instruction fetches access virtual memory.
When SUM=0, S-mode memory accesses to pages that are accessible by U-mode will fault.  When SUM=1, these accesses are
permitted.  SUM has no effect when page-based virtual memory is not in effect.
Note that, while SUM is ordinarily ignored when not executing in S-mode, it
{\em is} in effect when MPRV=1 and MPP=S.  SUM is hardwired to 0 if S-mode is
not supported.

\subsubsection{Virtualization Management \& Context Extension Fields in
\texttt{mstatus} Register
}\label{virtualization-management-context-extension-fields-in-mstatus-register}

Virtualization and Context Extensions are not supported by the RV12 v1.x
implementation. The value of these fields will therefore be permanently
set to 0.

\subsection{Machine Trap-Handler Base Address Register
(\texttt{mtvec})}\label{machine-trap-handler-base-address-register-mtvec}

The \texttt{mtvec} register is an XLEN-bit read/write register that holds
trap vector configuration, consisting of a vector base address (BASE) and a
vector mode (MODE).

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
	\begin{center}
	\begin{tabular}{J@{}S}
	\instbitrange{XLEN-1}{2} &
	\instbitrange{1}{0} \\
	\hline
	\multicolumn{1}{|c|}{BASE[XLEN-1:2] (\warl)} &
	\multicolumn{1}{c|}{MODE (\warl)} \\
	\hline
	XLEN-2 & 2 \\
	\end{tabular}
	\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine trap-vector base-address register (\texttt{mtvec}).}
	\label{fig:mtvecreg}
\end{figure*}



\fi

The encoding of the MODE field is shown in Table~\ref{mtvec-mode}.  When
MODE=Direct, all traps into machine mode cause the \texttt{pc} to be set to the
address in the BASE field.  When MODE=Vectored, all synchronous exceptions
into machine mode cause the \texttt{pc} to be set to the address in the BASE
field, whereas interrupts cause the \texttt{pc} to be set to the address in
the BASE field plus four times the interrupt cause number.

\begin{table*}[ht!]
\begin{center}
\begin{tabular}{|r|c|l|}
\hline
Value & Name & Description \\
\hline
0      & Direct   & All exceptions set \texttt{pc} to BASE. \\
1      & Vectored & Asynchronous interrupts set \texttt{pc} to BASE+4$\times$cause. \\
$\ge$2 & --- & \emph{Reserved} \\
\hline
\end{tabular}
\end{center}
\caption{Encoding of \texttt{mtvec} MODE field.}
\label{mtvec-mode}
\end{table*}

\subsection{Machine Delegation Registers
(\texttt{medeleg} \& \texttt{mideleg})} \label{machine-exception-interrupt-delegation-registers-medeleg-mideleg}

The machine exception delegation register (\texttt{medeleg}) and machine interrupt delegation register (\texttt{mideleg}) are XLEN-bit read/write registers used to indicate that certain exceptions and interrupts should be processed directly by a lower privilege level.

When a trap is delegated to a less-privileged mode \emph{x}, the
\emph{x}\,\texttt{cause} register is written with the trap cause; the
\emph{x}\,\texttt{epc} register is written with the virtual address of
the instruction that took the trap; the \emph{x}\,PP field
of \texttt{mstatus} is written with the active privilege mode at the time of
the trap; the \emph{x}\,PIE field of \texttt{mstatus} is written with the
value of the active interrupt-enable bit at the time of the trap; and
the \emph{x}\,IE field of \texttt{mstatus} is cleared.  The \texttt{mcause} and
\texttt{mepc} registers and the MPP and MPIE fields of \texttt{mstatus} are
not written.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}U}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Synchronous Exceptions} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Exception Delegation Register \texttt{medeleg}.}
	\label{fig:medelegreg}
\end{figure}
\fi

\texttt{medeleg} has a bit position allocated for every synchronous exception
with the index of the bit position equal to the value returned in the
\texttt{mcause} register (i.e. setting bit 8 allows user-mode environment calls
to be delegated to a lower-privilege trap handler).

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}U}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupts} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Exception Delegation Register \texttt{mideleg}.}
	\label{fig:midelegreg}
\end{figure}

\fi

\texttt{mideleg} holds trap delegation bits for individual interrupts, with the
layout of bits matching those in the \texttt{mip} register (i.e. \texttt{STIP}
interrupt delegation control is located in bit 5).

\subsection{Machine Interrupt Registers (\texttt{mie},
\texttt{mip})}\label{machine-interrupt-registers-mie-mip}

The \texttt{mip} register is an XLEN-bit read/write register containing
information on pending interrupts, while \texttt{mie} is the corresponding XLEN-
bit read/write register containing interrupt enable bits.  Only the bits
corresponding to lower-privilege software interrupts (USIP, SSIP), timer
interrupts (UTIP, STIP), and external interrupts (UEIP, SEIP) in \texttt{mip}
are writable through this CSR address; the remaining bits are read-only.

Restricted views of the \texttt{mip} and \texttt{mie} registers appear as the
\texttt{sip}/\texttt{sie}, and \texttt{uip}/\texttt{uie} registers in S-mode and
U-mode respectively.  If an interrupt is delegated to privilege mode \emph{x} by
setting a bit in the \texttt{mideleg} register, it becomes visible in the
\emph{x}\,\texttt{ip} register and is maskable using the \emph{x}\,\texttt{ie}
register.  Otherwise, the corresponding bits in \emph{x}\,\texttt{ip} and
\emph{x}\,\texttt{ie} appear to be hardwired to zero.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{Ycccccccccccc}
\instbitrange{XLEN-1}{12} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{MEIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SEIP} &
\multicolumn{1}{c|}{UEIP} &
\multicolumn{1}{c|}{MTIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{STIP} &
\multicolumn{1}{c|}{UTIP} &
\multicolumn{1}{c|}{MSIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SSIP} &
\multicolumn{1}{c|}{USIP} \\
\hline
XLEN-12 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine interrupt-pending register (\texttt{mip}).}
\label{mipreg}
\end{figure*}

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{Ycccccccccccc}
\instbitrange{XLEN-1}{12} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{MEIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SEIE} &
\multicolumn{1}{c|}{UEIE} &
\multicolumn{1}{c|}{MTIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{STIE} &
\multicolumn{1}{c|}{UTIE} &
\multicolumn{1}{c|}{MSIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SSIE} &
\multicolumn{1}{c|}{USIE} \\
\hline
XLEN-12 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine interrupt-enable register (\texttt{mie}).}
\label{miereg}
\end{figure*}

\fi

The MTIP, STIP, UTIP bits correspond to timer interrupt-pending bits
for machine, supervisor, and user timer interrupts, respectively.  The
MTIP bit is read-only and is cleared by writing to the memory-mapped
machine-mode timer compare register.  The UTIP and STIP bits may be
written by M-mode software to deliver timer interrupts to lower
privilege levels.  User and supervisor software may clear the UTIP and
STIP bits with calls to the AEE and SEE respectively.

There is a separate timer interrupt-enable bit, named MTIE, STIE, and
UTIE for M-mode, S-mode, and U-mode timer interrupts respectively.

Each lower privilege level has a separate software interrupt-pending
bit (SSIP, USIP), which can be both read and written by CSR accesses
from code running on the local hart at the associated or any higher
privilege level. The machine-level MSIP bits are written by accesses
to memory-mapped control registers, which are used by remote harts to
provide machine-mode interprocessor interrupts.

The MEIP field in \texttt{mip} is a read-only bit that indicates a machine-mode
external interrupt is pending.  MEIP is set and cleared by a platform-specific
interrupt controller.  The MEIE field in \texttt{mie} enables machine
external interrupts when set.

The SEIP field in \texttt{mip} contains a single read-write bit.  SEIP
may be written by M-mode software to indicate to S-mode that an
external interrupt is pending.


The UEIP field in \texttt{mip} provides user-mode external interrupts when the
N extension for user-mode interrupts is implemented.  It is defined
analogously to SEIP.

The MEIE, SEIE, and UEIE fields in the \texttt{mie} CSR enable M-mode external
interrupts, S-mode external interrupts, and U-mode external interrupts,
respectively.

For all the various interrupt types (software, timer, and external),
if a privilege level is not supported, the associated pending and
interrupt-enable bits are hardwired to zero in the \texttt{mip} and \texttt{mie} registers respectively.

An interrupt \emph{i} will be taken if bit \emph{i} is set in both \texttt{mip} and \texttt{mie}, and if interrupts are globally enabled.  By
default, M-mode interrupts are globally enabled if the hart's current
privilege mode is less than M, or if the current privilege mode is M
and the MIE bit in the \texttt{mstatus} register is set.  If bit \emph{i}
in \texttt{mideleg} is set, however, interrupts are considered to be
globally enabled if the hart's current privilege mode equals the
delegated privilege mode (S or U) and that mode's interrupt enable
bit (SIE or UIE in \texttt{mstatus}) is set, or if the current
privilege mode is less than the delegated privilege mode.

Multiple simultaneous interrupts and traps at the same privilege level
are handled in the following decreasing priority order: external
interrupts, software interrupts, timer interrupts, then finally any
synchronous traps.

\subsection{Machine Non-Maskable Interrupt Vector
(\texttt{mnmivec})}\label{machine-non-maskable-interrupt-vector-mnmivec}

The mnmivec register is an XLEN-bit read/write register that holds the
base address of the non-maskable interrupt trap vector. When an
exception occurs, the pc is set to mnmivec.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{mnmivec}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Non-Maskable Interrupt Vector}
	\label{fig:mnmivecreg}
\end{figure}

\fi

\subsection{Machine Trap Handler Scratch Register
(\texttt{mscratch})}\label{machine-trap-handler-scratch-register-mscratch}

The \texttt{mscratch} register is an XLEN-bit read/write register dedicated for
use by machine mode. It is used to hold a pointer to a machine-mode
hart-local context space and swapped with a user register upon entry to
an M-mode trap handler.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{mscratch}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine-mode scratch register.}
	\label{fig:mscratchreg}
\end{figure}

\fi

\subsection{Machine Exception Program Counter Register
(\texttt{mepc})}\label{machine-exception-program-counter-register-mepc}

\texttt{mepc} is an XLEN-bit read/write register. The two low bits
(mepc[1:0]) are always zero.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{mepc}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine exception program counter register.}
	\label{fig:mepcreg}
\end{figure}

\fi

When a trap is taken, \texttt{mepc} is written with the virtual address of the
instruction that encountered the exception.

\subsection{Machine Trap Cause Register
(\texttt{mcause})}\label{machine-trap-cause-register-mcause}

The \texttt{mcause} register is an XLEN-bit read-write register. The Interrupt
bit is set if the exception was caused by an interrupt. The Exception
Code field contains a code identifying the last exception. The remaining
center bits will read zero

\ifdefined\MARKDOWN
% Skip Row
\else
\begin{figure}[!ht]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}U}
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupt} &
				\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
				\hline
				1 & XLEN-1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Cause register \texttt{mcause}.}
	\label{fig:mcausereg}
\end{figure}
\fi

\ifdefined\MARKDOWN
See PDF Datasheet for further details
\else
Table \ref{tab:mcause-reg-values} below lists the possible machine-level exception codes.

\begin{longtable}[]{@{}ccl@{}}
\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endfirsthead
\multicolumn{3}{c}{{(Continued from previous page)}} \\

\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endhead

\midrule \multicolumn{3}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
\endfoot

\endlastfoot
  1         & 0               & User software interrupt \\
  1         & 1               & Supervisor software interrupt \\
  1         & 2               & \emph{Reserved} \\
  1         & 3               & Machine software interrupt \\ \hline
  1         & 4               & User timer interrupt \\
  1         & 5               & Supervisor timer interrupt \\
  1         & 6               & \emph{Reserved} \\
  1         & 7               & Machine timer interrupt \\ \hline
  1         & 8               & User external interrupt \\
  1         & 9               & Supervisor external interrupt \\
  1         & 10              & \emph{Reserved} \\
  1         & 11              & Machine external interrupt \\ \hline
  1         & $\ge$12         & \emph{Reserved} \\ \hline
  0         & 0               & Instruction address misaligned \\
  0         & 1               & Instruction access fault \\
  0         & 2               & Illegal instruction \\
  0         & 3               & Breakpoint \\
  0         & 4               & Load address misaligned \\
  0         & 5               & Load access fault \\
  0         & 6               & Store/AMO address misaligned \\
  0         & 7               & Store/AMO access fault \\
  0         & 8               & Environment call from U-mode\\
  0         & 9               & Environment call from S-mode \\
  0         & 10              & \emph{Reserved} \\
  0         & 11              & Environment call from M-mode \\
  0         & 12              & Instruction page fault \\
  0         & 13              & Load page fault \\
  0         & 14              & \emph{Reserved} \\
  0         & 15              & Store/AMO page fault \\
  0         & $\ge$16         & \emph{Reserved} \\
\bottomrule
\caption{Machine Cause Register Values}
\label{tab:mcause-reg-values}
\end{longtable}

\fi

\subsection{Machine Trap Value Register
(\texttt{mtval})}\label{machine-trap-value-register-mtval}

The \texttt{mtval} register is an XLEN-bit read-write register formatted as shown in Figure~\ref{fig:mtvalreg}.

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure}[!ht]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{mtval}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine trap value register.}
	\label{fig:mtvalreg}
\end{figure}
\fi

When a trap is taken into M-mode, \texttt{mtval} is
written with exception-specific information to assist software in handling the
trap.  Otherwise, \texttt{mtval} is never written by the implementation, though
it may be explicitly written by software.

When a hardware
breakpoint is triggered, or an instruction-fetch, load, or store
address-misaligned, access, or page-fault exception occurs, \texttt{mtval} is
written with the faulting effective address.  On an illegal instruction trap,
\texttt{mtval} is written with the first XLEN bits of the faulting
instruction as described below.  For other exceptions, \texttt{mtval} is
set to zero, but a future standard may redefine \texttt{mtval}'s setting for
other exceptions.

For instruction-fetch access faults with variable-length instructions,
\texttt{mtval} will point to the portion of the instruction that caused the
fault while \texttt{mepc} will point to the beginning of the instruction.

\subsection{Counter-Enable Registers (\texttt{[m|s]counteren})}
\label{sec:mcounteren}
\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cccTcccccc}
\instbit{31} &
\instbit{30} &
\instbit{29} &
\instbitrange{28}{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{HPM31} &
\multicolumn{1}{c|}{HPM30} &
\multicolumn{1}{c|}{HPM29} &
\multicolumn{1}{c|}{...} &
\multicolumn{1}{c|}{HPM5} &
\multicolumn{1}{c|}{HPM4} &
\multicolumn{1}{c|}{HPM3} &
\multicolumn{1}{c|}{IR} &
\multicolumn{1}{c|}{TM} &
\multicolumn{1}{c|}{CY} \\
\hline
1 & 1 & 1 & 23 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Counter-enable registers (\texttt{mcounteren} and \texttt{scounteren}).}
\label{mcounteren}
\end{figure*}
\fi

Note: Machine performnce counters are currently unsupported and therefore all HPM\emph{n} bits are hardwired to '0'.

The counter-enable registers \texttt{mcounteren} and \texttt{scounteren}
control the availability of the hardware performance monitoring
counters to the next-lowest privileged mode.

When the CY, TM or IR bit in the \texttt{mcounteren}
register is clear, attempts to read the \texttt{cycle}, \texttt{time}, or
\texttt{instret} register while executing in
S-mode or U-mode will cause an illegal instruction exception.  When
one of these bits is set, access to the corresponding register is
permitted in the next implemented privilege mode (S-mode if
implemented, otherwise U-mode).

If S-mode is implemented, the same bit positions in the \texttt{scounteren}
register analogously control access to these registers while executing
in U-mode.  If S-mode is permitted to access a counter register and the
corresponding bit is set in \texttt{scounteren}, then U-mode is also permitted
to access that register.

\subsection{Machine Cycle Counter (\texttt{mcycle},
\texttt{mcycleh})}\label{machine-cycle-counter-mcycle-mcycleh}

The \texttt{mcycle} CSR holds a count of the number of cycles the hart has
executed since some arbitrary time in the past. The \texttt{mcycle} register has
64-bit precision on all RV32 and RV64 systems.

On RV32 only, reads of the \texttt{mcycle} CSR returns the low 32 bits, while
reads of the \texttt{mcycleh} CSR returns bits 63--32.

\subsection{Machine Instructions-Retired counter (\texttt{minstret},
\texttt{minstreth})} \label{machine-instructions-retired-counter-minstret-minstreth}

The \texttt{minstret} CSR holds a count of the number of instructions the hart
has retired since some arbitrary time in the past. The \texttt{minstret}
register has 64-bit precision on all RV32 and RV64 systems.

On RV32 only, reads of the \texttt{minstret} CSR returns the low 32 bits, while
reads of the \texttt{minstreth} CSR returns bits 63--32.

\subsection{Machine Performance counters (\texttt{mhpmcounter},
\texttt{mhpmcounter})} \label{machine-performance-counters-mhpmcounter-mhpmcounterh}

The Machine High Performance counters \texttt{mhpmcounter3-31, mhpmcounter3-31h} are implemented but unsupported in the current RV12 implementation.

\subsection{Machine Performance event selectors (\texttt{mhpevent})} \label{machine-performance-event-selectors-mhpevent}

The Machine High Performance event selector CSRs \texttt{mhpevent3-31} are implemented but unsupported in the current RV12 implementation.

\section{Supervisor Mode CSRs}\label{supervisor-mode-csrs}

\subsection{Supervisor Status Register (sstatus)
}\label{supervisor-status-register-sstatus}

The sstatus register is an XLEN-bit read/write register. The sstatus register
keeps track of the processor's current operating state.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{cYccccWcWccWcc}
				\\
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{19} &
				\instbit{18} &
				\instbit{17} &
				\instbitrange{16}{15} &
				\instbitrange{14}{13} &
				\instbitrange{12}{9} &
				\instbit{8} &
				\instbitrange{7}{6} &
				\instbit{5} &
				\instbit{4} &
				\instbitrange{3}{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{SD} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{PUM} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{XS[1:0]} &
				\multicolumn{1}{c|}{FS[1:0]} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SPP} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SPIE} &
				\multicolumn{1}{c|}{UPIE} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SIE}  &
				\multicolumn{1}{c|}{UIE}
				\\
				\hline
				1 & XLEN-20 & 1 & 1 & 2 & 2 & 4 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor-mode status Register.}
	\label{fig:sstatusreg}
\end{figure*}

\fi

The \texttt{SPP} bit indicates the privilege level at which a \emph{hart} was
executing before entering supervisor mode. When a trap is taken, \texttt{SPP} is
set to 0 if the trap originated from user mode, or 1 otherwise. When an
\texttt{SRET} instruction is executed to return from the trap handler, the
privilege level is set to user mode if the \texttt{SPP} bit is 0, or supervisor
mode if the \texttt{SPP} bit is 1; \texttt{SPP} is then set to 0.

The \texttt{SIE} bit enables or disables all interrupts in supervisor mode. When
\texttt{SIE} is clear, interrupts are not taken while in supervisor mode. When
the \emph{hart} is running in user-mode, the value in \texttt{SIE} is ignored,
and supervisor-level interrupts are enabled. The supervisor can disable
indivdual interrupt sources using the \texttt{sie} register.

The \texttt{SPIE} bit indicates whether interrupts were enabled before entering
supervisor mode. When a trap is taken into supervisor mode, \texttt{SPIE} is set
to either \texttt{SIE} or \texttt{UIE} depending on whether the trap was taken in
supervisor or user mode respectively, and \texttt{SIE} is set to 0. When an \texttt{SRET}
instruction is executed, if \texttt{SPP=S}, then \texttt{SIE} is set to \texttt{SPIE}; or if \texttt{SPP=U},
then \texttt{UIE} is set to \texttt{SPIE}. In either case, \texttt{SPIE} is then set to 1.

The \texttt{UIE} bit enables or disables user-mode interrupts. User-level
interrupts are enabled only if \texttt{UIE} is set and the \emph{hart} is
running in user-mode. The \texttt{UPIE} bit indicates whether user-level
interrupts were enabled prior to taking a user-level trap. When a \texttt{URET}
instruction is executed, \texttt{UIE} is set to \texttt{UPIE}, and \texttt{UPIE}
is set to 1.

\subsubsection{Memory Privilege in \texttt{sstatus} Register
}\label{memory-privilege-in-sstatus-register}

The \texttt{PUM} (Protect User Memory) bit modifies the privilege with which
S-mode loads, stores, and instruction fetches access virtual memory. When
\texttt{PUM=0}, translation and protection behave as normal. When
\texttt{PUM=1}, S-mode memory accesses to pages that are accessible by U-mode
will fault. \texttt{PUM} has no effect when executing in U-mode.

\subsection{Supervisor Trap Delegation Registers (\texttt{sedeleg},
\texttt{sideleg})}\label{supervisor-trap-delegation-registers-sedeleg-sideleg}

The supervisor exception delegation register (\texttt{sedeleg}) and supervisor
interrupt delegation register (\texttt{sideleg}) are XLEN-bit read/write
registers.

In systems with all three privilege modes (M/S/U), setting a bit in
\texttt{medeleg} or \texttt{mideleg} will delegate the corresponding trap in
S-mode or U-mode to the S-mode trap handler. If U-mode traps are
supported, S-mode may in turn set corresponding bits in the \texttt{sedeleg} and \texttt{sideleg} registers to delegate traps that occur in
U-mode to the U-mode trap handler.

\subsection{Supervisor Interrupt Registers (sip, sie)}

The \texttt{sip} register is an XLEN-bit read/write register containing
information on pending interrupts, while \texttt{sie} is the corresponding
XLEN-bit read/write register containing interrupt enable bits.
\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{EccFccFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbit{8} &
\instbitrange{7}{6} &
\instbit{5} &
\instbit{4} &
\instbitrange{3}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{SEIP} &
\multicolumn{1}{c|}{UEIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{STIP} &
\multicolumn{1}{c|}{UTIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SSIP} &
\multicolumn{1}{c|}{USIP} \\
\hline
XLEN-10 & 1 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor interrupt-pending register (\texttt{sip}).}
\label{sipreg}
\end{figure*}

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{EccFccFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbit{8} &
\instbitrange{7}{6} &
\instbit{5} &
\instbit{4} &
\instbitrange{3}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{SEIE} &
\multicolumn{1}{c|}{UEIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{STIE} &
\multicolumn{1}{c|}{UTIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SSIE} &
\multicolumn{1}{c|}{USIE} \\
\hline
XLEN-10 & 1 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor interrupt-enable register (\texttt{sie}).}
\label{siereg}
\end{figure*}
\fi

Three types of interrupts are defined: software interrupts, timer interrupts,
and external interrupts.  A supervisor-level software interrupt is triggered
on the current hart by writing 1 to its supervisor software interrupt-pending
(SSIP) bit in the \texttt{sip} register.  A pending supervisor-level software
interrupt can be cleared by writing 0 to the SSIP bit in \texttt{sip}.
Supervisor-level software interrupts are disabled when the SSIE bit in the
\texttt{sie} register is clear.

Interprocessor interrupts are sent to other harts by means of SBI
calls, which will ultimately cause the SSIP bit to be set in the
recipient hart's \texttt{sip} register.

A user-level software interrupt is triggered on the current hart by writing
1 to its user software interrupt-pending (USIP) bit in the \texttt{sip} register.
A pending user-level software interrupt can be cleared by writing 0 to the
USIP bit in \texttt{sip}.  User-level software interrupts are disabled when the
USIE bit in the \texttt{sie} register is clear.  If user-level interrupts are not
supported, USIP and USIE are hardwired to zero.

All bits besides SSIP, USIP, and UEIP in the \texttt{sip} register are read-only.

A supervisor-level timer interrupt is pending if the STIP bit in the \texttt{sip}
register is set.  Supervisor-level timer interrupts are disabled when the STIE
bit in the \texttt{sie} register is clear.  An SBI call to the SEE may be used to
clear the pending timer interrupt.

A user-level timer interrupt is pending if the UTIP bit in the \texttt{sip}
register is set.  User-level timer interrupts are disabled when the UTIE bit
in the \texttt{sie} register is clear.  If user-level interrupts are supported,
the ABI should provide a facility for scheduling timer interrupts in terms of
real-time counter values.  If user-level interrupts are not supported, UTIP
and UTIE are hardwired to zero.

A supervisor-level external interrupt is pending if the SEIP bit in the
\texttt{sip} register is set.  Supervisor-level external interrupts are disabled
when the SEIE bit in the \texttt{sie} register is clear.  The SBI should provide
facilities to mask, unmask, and query the cause of external interrupts.

The UEIP field in \texttt{sip} contains a single read-write bit.  UEIP
may be written by S-mode software to indicate to U-mode that an
external interrupt is pending.  Additionally, the platform-level
interrupt controller may generate user-level external interrupts.  The
logical-OR of the software-writeable bit and the signal from the
external interrupt controller are used to generate external interrupts
for user mode.  When the UEIP bit is read with a CSRRW, CSRRS, or
CSRRC instruction, the value returned in the \texttt{rd} destination
register contains the logical-OR of the software-writable bit and the
interrupt signal from the interrupt controller.  However, the value
used in the read-modify-write sequence of a CSRRS or CSRRC instruction
is only the software-writable UEIP bit, ignoring the interrupt value
from the external interrupt controller.

User-level external interrupts are disabled when the UEIE bit in the \texttt{sie}
register is clear.  If the N extension for user-level interrupts is not
implemented, UEIP and UEIE are hardwired to zero.

\subsection{Supervisor Trap Vector Register
(\texttt{stvec})}\label{supervisor-trap-vector-register-stvec}

The \texttt{stvec} register is an XLEN-bit read/write register that holds the
base address of the S-mode trap vector. When an exception occurs, the pc
is set to \texttt{stvec}. The \texttt{stvec} register is always aligned to a 4-byte
boundary.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J@{}F}
				\instbitrange{XLEN-1}{2} &
				\instbitrange{1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Trap-Vector Base Address (\warl)} &
				\multicolumn{1}{c|}{0} \\
				\hline
				XLEN-2 & 2 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor trap-vector base-address register (\texttt{mtvec}).}
	\label{fig:stvecreg}
\end{figure*}

\fi

The \texttt{stvec} register is an XLEN-bit read/write register that holds
trap vector configuration, consisting of a vector base address (BASE) and a
vector mode (MODE).

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{XLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[XLEN-1:2] (\wlrl)} &
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
XLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor trap vector base address register (\texttt{stvec}).}
\label{stvecreg}
\end{figure*}

\fi

The BASE field in \texttt{stvec} is a \warl\ field that can hold any valid virtual
or physical address, subject to the following alignment constraints: the
address must always be at least 4-byte aligned, and the MODE
setting may impose additional alignment constraints on the value in the BASE
field.

\begin{table*}[ht!]
\begin{center}
\begin{tabular}{|r|c|l|}
\hline
Value & Name & Description \\
\hline
0      & Direct   & All exceptions set \texttt{pc} to BASE. \\
1      & Vectored & Asynchronous interrupts set \texttt{pc} to BASE+4$\times$cause. \\
$\ge$2 & --- & \emph{Reserved} \\
\hline
\end{tabular}
\end{center}
\caption{Encoding of \texttt{stvec} MODE field.}
\label{stvec-mode}
\end{table*}

The encoding of the MODE field is shown in Table~\ref{stvec-mode}.  When
MODE=Direct, all traps into supervisor mode cause the \texttt{pc} to be set to the
address in the BASE field.  When MODE=Vectored, all synchronous exceptions
into supervisor mode cause the \texttt{pc} to be set to the address in the BASE
field, whereas interrupts cause the \texttt{pc} to be set to the address in
the BASE field plus four times the interrupt cause number.

\subsection{Supervisor Scratch Register (\texttt{sscratch})
}\label{supervisor-scratch-register-sscratch}

The \texttt{sscratch} register is an XLEN-bit read/write register, dedicated for
use by the supervisor. Typically, \texttt{sscratch} is used to hold a pointer to
the hart-local supervisor context while the hart is executing user code.
At the beginning of a trap handler, \texttt{sscratch} is swapped with a user
register to provide an initial working register.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{sscratch}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor Scratch Register.}
	\label{fig:sscratchreg}
\end{figure}

\fi

\subsection{Supervisor Exception Program Counter
(\texttt{sepc})}\label{supervisor-exception-program-counter-sepc}

\texttt{sepc} is an XLEN-bit read/write register formatted as shown in Figure
7â€‘24. The low bit of \texttt{sepc} (\texttt{sepc{[}0{]}}) is always zero. On
implementations that do not support instruction-set extensions with
16-bit instruction alignment, the two low bits (\texttt{sepc{[}1:0{]}}) are
always zero. When a trap is taken, \texttt{sepc} is written with the virtual
address of the instruction that encountered the exception.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{sepc}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor exception program counter register.}
	\label{epcreg}
\end{figure}

\fi

\subsection{Supervisor Cause Register (\texttt{scause})
}\label{supervisor-cause-register-scause}

The \texttt{scause} register is an XLEN-bit read-only register. The Interrupt
bit is set if the exception was caused by an interrupt. The Exception Code field
contains a code identifying the last exception.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}U}
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupt} &
				\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
				\hline
				1 & XLEN-1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor Cause register \texttt{scause}.}
	\label{scausereg}
\end{figure*}

Table \ref{tab:scause-reg-values} below lists the possible exception codes for the current supervisor ISAs.
\fi

\begin{longtable}[]{@{}ccl@{}}
\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule

\ifdefined\MARKDOWN
\endhead
\else

\endfirsthead
\multicolumn{3}{c}{{(Continued from previous page)}} \\

\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endhead

\midrule \multicolumn{3}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
\endfoot

\endlastfoot

\fi

  1         & 0               & User software interrupt \\
  1         & 1               & Supervisor software interrupt \\
  1         & 2--3            & \emph{Reserved} \\
  1         & 4               & User timer interrupt \\
  1         & 5               & Supervisor timer interrupt \\
  1         & 6--7            & \emph{Reserved} \\
  1         & 8               & User external interrupt \\
  1         & 9               & Supervisor external interrupt \\
  1         & $\ge$10         & \emph{Reserved} \\ \hline
  0         & 0               & Instruction address misaligned \\
  0         & 1               & Instruction access fault \\
  0         & 2               & Illegal instruction \\
  0         & 3               & Breakpoint \\
  0         & 4               & \emph{Reserved} \\
  0         & 5               & Load access fault \\
  0         & 6               & AMO address misaligned \\
  0         & 7               & Store/AMO access fault \\
  0         & 8               & Environment call \\
  0         & 9--11           & \emph{Reserved} \\
  0         & 12              & Instruction page fault \\
  0         & 13              & Load page fault \\
  0         & 14              & \emph{Reserved} \\
  0         & 15              & Store/AMO page fault \\
  0         & $\ge$16         & \emph{Reserved} \\
\bottomrule
\caption{Supervisor Cause Register Values}
\label{tab:scause-reg-values}
\end{longtable}

\subsection{Supervisor Trap Value Register
(\texttt{stval})}\label{supervisor-trap-value-register-sbadaddr}

The \texttt{stval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{fig:stval}.  When a trap is taken into S-mode, \texttt{stval} is
written with exception-specific information to assist software in handling the
trap.  Otherwise, \texttt{stval} is never written by the implementation, though
it may be explicitly written by software.

When a hardware breakpoint is triggered, or
an instruction-fetch, load, or store access or page-fault exception occurs,
or an instruction-fetch or AMO address-misaligned exception occurs,
\texttt{stval} is written with the faulting address.
For other exceptions, \texttt{stval} is
set to zero, but a future standard may redefine \texttt{stval}'s setting for
other exceptions.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[!ht]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{\texttt{stval}} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor trap value register.}
	\label{fig:stval}
\end{figure}

\fi

For instruction-fetch access faults and page faults on RISC-V systems with
variable-length instructions, \texttt{stval} will point to the portion
of the instruction that caused the fault while \texttt{sepc} will point
to the beginning of the instruction.

The \texttt{stval} register can optionally also be used to return the
faulting instruction bits on an illegal instruction exception ({\tt
  sepc} points to the faulting instruction in memory).

After an illegal instruction trap, {\tt
  stval} will contain the entire faulting instruction provided the
instruction is no longer than XLEN bits.  If the instruction is less
than XLEN bits long, the upper bits of \texttt{stval} are cleared to
zero. If the instruction is more than XLEN bits long, \texttt{stval}
will contain the first XLEN bits of the instruction.

\subsection{Counter-Enable Register (\texttt{scounteren})}

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure*}[ht!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cccMcccccc}
\instbit{31} &
\instbit{30} &
\instbit{29} &
\instbitrange{28}{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{...} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{IR} &
\multicolumn{1}{c|}{TM} &
\multicolumn{1}{c|}{CY} \\
\hline
1 & 1 & 1 & 23 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Counter-enable register (\texttt{scounteren}).}
\label{scounteren}
\end{figure*}
\fi

The counter-enable register \texttt{scounteren} controls
the availability of the
hardware performance monitoring counters to U-mode.

When the CY, TM, or IR bit in the \texttt{scounteren} register is
clear, attempts to read the \texttt{cycle}, \texttt{time} or \texttt{instret} register while executing in U-mode
will cause an illegal instruction exception.  When one of these bits is set,
access to the corresponding register is permitted.




\section{User Mode CSRs}\label{user-mode-csrs}


\subsection{User Trap Setup \& Handling CSRs} \label{user-trap-setup-handling-csrs}

The following CSRs are shadow registers of their Machine and Supervisor Mode counterparts, providing access only to User Mode bits where relevant. See the Machine Mode and Supervisor Mode descriptions for more information

	\texttt{ustatus}

	\texttt{uie \& uip}

	\texttt{utvec}

	\texttt{uscratch}

	\texttt{uepc}

	\texttt{ucause}

	\texttt{utval}


\subsection{Cycle counter for RDCYCLE instruction (\texttt{cycle})} \label{cycle-counter-for-rdcycle-instruction-cycle}

\texttt{cycle} is an XLEN-bit read-only register. The \texttt{RDCYCLE} pseudo-instruction
reads the low XLEN bits of the \texttt{cycle} CSR that holds a count of the
number of clock cycles executed by the processor on which the hardware
thread is running from an arbitrary start time in the past.

\subsection{Time counter for RDTIME instruction (\texttt{time})} \label{time-counter-for-rdtime-instruction}

\texttt{time} is an XLEN-bit read-only register. The \texttt{RDTIME} pseudo-instruction
reads the \texttt{time} CSR, where the underlying action causes a trap and enables the ABI return the time value.

\subsection{Instruction-retire counter for RDINSTRET instruction
(\texttt{instret})}\label{instruction-retire-counter-for-rdinstret-instruction-instret}

\texttt{instret} is an XLEN-bit read-only register. The RDINSTRET
pseudo-instruction reads the low XLEN bits of the \texttt{instret} CSR, which
counts the number of instructions retired by this hardware thread from
some arbitrary start point in the past.

\subsection{High Performance Monitoring Counters (\texttt{hpmcounter})} \label{high-performance-monitoring-counters}

\texttt{hpmcounter3} -- \texttt{hpmcounter31} are implemented but unsupported in RV12.

\subsection{Upper 32bits of cycle (\texttt{cycleh} - RV32I
only)}\label{upper-32bits-of-cycle-cycleh---rv32i-only}

\texttt{cycleh} is a read-only register that contains bits 63-32 of the counter
of the number of clock cycles executed by the processor.

\texttt{RDCYCLEH} is an RV32I-only instruction providing access to this register.

\subsection{Upper 32bits of instret (\texttt{instreth} - RV32I
only)}\label{upper-32bit-of-instret-instreth---rv32i-only}

\texttt{instreth} is a read-only register that contains bits 63-32 of the
instruction counter.

\texttt{RDINSTRETH} is an RV32I-only instruction providing access to this
register

\subsection{Upper 32bits of hpmcounter (\texttt{hpmcounterh} - RV32I
only)} \label{high-performance-monitoring-counters-rv32}

\texttt{hpmcounter3h} -- \texttt{hpmcounter31h} are implemented but unsupported in RV12.




\section{Physical Memory Protection CSRs}

PMP entries are described by an 8-bit configuration register and one XLEN-bit
address register supporting up to 16 PMP entries. PMP CSRs are only accessible to M-mode.

The PMP configuration registers are densely packed into CSRs to minimize
context-switch time.  For RV32, four CSRs, \texttt{pmpcfg0}--\texttt{pmpcfg3}, hold
the configurations \texttt{pmp0cfg}--\texttt{pmp15cfg} for the 16 PMP entries, as
shown in Figure~\ref{pmpcfg-rv32}.  For RV64, \texttt{pmpcfg0} and \texttt{pmpcfg2}
hold the configurations for the 16 PMP entries, as shown in
Figure~\ref{pmpcfg-rv64}; \texttt{pmpcfg1} and \texttt{pmpcfg3} are illegal.

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}Y@{}Y@{}Y@{}Yl}
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-4}
\multicolumn{1}{|c|}{pmp3cfg} &
\multicolumn{1}{c|}{pmp2cfg} &
\multicolumn{1}{c|}{pmp1cfg} &
\multicolumn{1}{c|}{pmp0cfg} &
\tt pmpcfg0 \\
\cline{1-4}
8 & 8 & 8 & 8 & \\
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-4}
\multicolumn{1}{|c|}{pmp7cfg} &
\multicolumn{1}{c|}{pmp6cfg} &
\multicolumn{1}{c|}{pmp5cfg} &
\multicolumn{1}{c|}{pmp4cfg} &
\tt pmpcfg1 \\
\cline{1-4}
8 & 8 & 8 & 8 & \\
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-4}
\multicolumn{1}{|c|}{pmp11cfg} &
\multicolumn{1}{c|}{pmp10cfg} &
\multicolumn{1}{c|}{pmp9cfg} &
\multicolumn{1}{c|}{pmp8cfg} &
\tt pmpcfg2 \\
\cline{1-4}
8 & 8 & 8 & 8 & \\
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-4}
\multicolumn{1}{|c|}{pmp15cfg} &
\multicolumn{1}{c|}{pmp14cfg} &
\multicolumn{1}{c|}{pmp13cfg} &
\multicolumn{1}{c|}{pmp12cfg} &
\tt pmpcfg3 \\
\cline{1-4}
8 & 8 & 8 & 8 & \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{RV32 PMP configuration CSR layout.}
\label{pmpcfg-rv32}
\end{figure}

\begin{figure}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}Y@{}Y@{}Y@{}Y@{}Y@{}Y@{}Y@{}Yl}
\instbitrange{63}{56} &
\instbitrange{55}{48} &
\instbitrange{47}{40} &
\instbitrange{39}{32} &
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-8}
\multicolumn{1}{|c|}{pmp7cfg} &
\multicolumn{1}{c|}{pmp6cfg} &
\multicolumn{1}{c|}{pmp5cfg} &
\multicolumn{1}{c|}{pmp4cfg} &
\multicolumn{1}{c|}{pmp3cfg} &
\multicolumn{1}{c|}{pmp2cfg} &
\multicolumn{1}{c|}{pmp1cfg} &
\multicolumn{1}{c|}{pmp0cfg} &
\tt pmpcfg0 \\
\cline{1-8}
8 & 8 & 8 & 8 & 8 & 8 & 8 & 8 & \\
\instbitrange{63}{56} &
\instbitrange{55}{48} &
\instbitrange{47}{40} &
\instbitrange{39}{32} &
\instbitrange{31}{24} &
\instbitrange{23}{16} &
\instbitrange{15}{8} &
\instbitrange{7}{0} & \\
\cline{1-8}
\multicolumn{1}{|c|}{pmp15cfg} &
\multicolumn{1}{c|}{pmp14cfg} &
\multicolumn{1}{c|}{pmp13cfg} &
\multicolumn{1}{c|}{pmp12cfg} &
\multicolumn{1}{c|}{pmp11cfg} &
\multicolumn{1}{c|}{pmp10cfg} &
\multicolumn{1}{c|}{pmp9cfg} &
\multicolumn{1}{c|}{pmp8cfg} &
\tt pmpcfg2 \\
\cline{1-8}
8 & 8 & 8 & 8 & 8 & 8 & 8 & 8 & \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{RV64 PMP configuration CSR layout.}
\label{pmpcfg-rv64}
\end{figure}
\fi

The PMP address registers are CSRs named \texttt{pmpaddr0}--\texttt{pmpaddr15}.
Each PMP address register encodes bits 33--2 of a 34-bit physical address for
RV32, as shown in Figure~\ref{pmpaddr-rv32}.  For RV64, each PMP address
register encodes bits 55--2 of a 56-bit physical address, as shown in
Figure~\ref{pmpaddr-rv64}.

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{31}{0} \\
\hline
\multicolumn{1}{|c|}{address[33:2] (\warl)} \\
\hline
32 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{PMP address register format, RV32.}
\label{pmpaddr-rv32}
\end{figure}

\begin{figure}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}F@{}J}
\instbitrange{63}{54} &
\instbitrange{53}{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{address[55:2] (\warl)} \\
\hline
32 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{PMP address register format, RV64.}
\label{pmpaddr-rv64}
\end{figure}
\fi

Figure~\ref{pmpcfg} shows the layout of a PMP configuration register.  The R,
W, and X bits, when set, indicate that the PMP entry permits read, write, and
instruction execution, respectively.  When one of these bits is clear, the
corresponding access type is denied.  The remaining 2 fields, A and L, are
described in the following sections.

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure}[ht!]
{\footnotesize
\begin{center}
\begin{tabular}{FFFRFFF}
\instbit{7} &
\instbitrange{6}{5} &
\instbitrange{4}{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{L (\warl)} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{A (\warl)} &
\multicolumn{1}{c|}{X (\warl)} &
\multicolumn{1}{c|}{W (\warl)} &
\multicolumn{1}{c|}{R (\warl)}
\\
\hline
1 & 2 & 2 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{PMP configuration register format.}
\label{pmpcfg}
\end{figure}
\fi

\subsection{Address Matching}

The A field in a PMP entry's configuration register encodes the
address-matching mode of the associated PMP address register.  The encoding of
this field is shown in Table~\ref{pmpcfg-a}.  When A=0, this PMP entry is
disabled and matches no addresses.  Two other address-matching modes are
supported: naturally aligned power-of-2 regions (NAPOT), including the special
case of naturally aligned four-byte regions (NA4); and the top boundary of an
arbitrary range (TOR).  These modes support four-byte granularity.

\begin{table*}[ht!]
\begin{center}
\begin{tabular}{|r|c|l|}
\hline
A & Name & Description \\
\hline
0 & OFF   & Null region (disabled) \\
1 & TOR   & Top of range \\
2 & NA4   & Naturally aligned four-byte region \\
3 & NAPOT & Naturally aligned power-of-two region, $\ge$8 bytes \\
\hline
\end{tabular}
\end{center}
\caption{Encoding of A field in PMP configuration registers.}
\label{pmpcfg-a}
\end{table*}

NAPOT ranges make use of the low-order bits of the associated address register
to encode the size of the range, as shown in Table~\ref{pmpcfg-napot}.

\begin{table*}[ht!]
\begin{center}
  \begin{tabular}{|c|c|l|}
  \hline
  \texttt{pmpaddr}    & \texttt{pmpcfg}.A & Match type and size \\
  \hline
  \texttt{aaaa...aaaa} & NA4   & 4-byte NAPOT range \\
  \texttt{aaaa...aaa0} & NAPOT & 8-byte NAPOT range \\
  \texttt{aaaa...aa01} & NAPOT & 16-byte NAPOT range \\
  \texttt{aaaa...a011} & NAPOT & 32-byte NAPOT range \\
  \multicolumn{1}{|c|}{\ldots} &  \ldots  & \multicolumn{1}{|c|}{\ldots} \\
  \texttt{aa01...1111} & NAPOT & $2^{XLEN}$-byte NAPOT range \\
  \texttt{a011...1111} & NAPOT & $2^{XLEN+1}$-byte NAPOT range \\
  \texttt{0111...1111} & NAPOT & $2^{XLEN+2}$-byte NAPOT range \\
  \hline
  \end{tabular}
\end{center}
\caption{NAPOT range encoding in PMP address and configuration registers.}
\label{pmpcfg-napot}
\end{table*}

If TOR is selected, the associated address register forms the top of the
address range, and the preceding PMP address register forms the bottom of the
address range.  If PMP entry $i$'s A field is set to TOR, the entry matches
any address $a$ such that $\texttt{pmpaddr}_{i-1}\leq a < \texttt{pmpaddr}_i$.  If
PMP entry 0's A field is set to TOR, zero is used for the lower bound, and so
it matches any address $a < \texttt{pmpaddr}_0$.

\subsection{Locking and Privilege Mode}

The L bit indicates that the PMP entry is locked, i.e., writes to the
configuration register and associated address registers are ignored.  Locked
PMP entries may only be unlocked with a system reset.  If PMP entry $i$ is
locked, writes to \texttt{pmp}$i$\texttt{cfg} and \texttt{pmpaddr}$i$ are ignored.
Additionally, if \texttt{pmp}$i$\texttt{cfg}.A is set to TOR, writes to {\tt
pmpaddr}$i$-1 are ignored.

In addition to locking the PMP entry, the L bit indicates whether the R/W/X
permissions are enforced on M-mode accesses.  When the L bit is set, these
permissions are enforced for all privilege modes.  When the L bit is clear,
any M-mode access matching the PMP entry will succeed; the R/W/X
permissions apply only to S and U modes.

%\subsection{Cacheability}
%
%The C bit indicates if the memory area is cacheable or not. When the C bit is
%set the corresponding memory area is cacheable.

\subsection{Priority and Matching Logic}

PMP entries are statically prioritized.  The lowest-numbered PMP entry that
matches any byte of an access determines whether that access succeeds or
fails.  The matching PMP entry must match all bytes of an access, or the
access fails, irrespective of the L, R, W, and X bits.  For example, if a PMP
entry is configured to match the four-byte range \texttt{0xC}--\texttt{0xF}, then an
8-byte access to the range \texttt{0x8}--\texttt{0xF} will fail, assuming that
PMP entry is the highest-priority entry that matches those addresses.

If a PMP entry matches all bytes of an access, then the L, R, W, and X bits
determine whether the access succeeds or fails.  If the L bit is clear and the
privilege mode of the access is M, the access succeeds.  Otherwise, if the
L bit is set or the privilege mode of the access is S or U, then the access
succeeds only if the R, W, or X bit corresponding to the access type is set.

If no PMP entry matches an M-mode access, the access succeeds.  If no PMP
entry matches an S-mode or U-mode access, but at least one PMP entry is
implemented, the access fails.

Failed accesses generate a load, store, or instruction access exception.  Note
that a single instruction may generate multiple accesses, which may not be
mutually atomic.  An access exception is generated if at least one access
generated by an instruction fails, though other accesses generated by that
instruction may succeed with visible side effects.  Notably, instructions that
reference virtual memory are decomposed into multiple accesses.
