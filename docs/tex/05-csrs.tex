\chapter{Control \& Status Registers}\label{control-status-registers}

\section{Introduction}\label{introduction-3}

The state of the CPU is maintained by the Control \& Status Registers
(CSRs). They determine the feature set, set interrupts and interrupt
masks, and determine the privilege level. The CSRs are mapped into an
internal 12bit address space and are accessible using special commands.

\section{Accessing the CSRs}\label{accessing-the-csrs}

\ifdefined\MARKDOWN
% Exclude Table
\else

\begin{figure*}[htb]
\begin{center}
	\begin{tabular}{M@{}R@{}F@{}R@{}S}
		\\
		\instbitrange{31}{20} &
		\instbitrange{19}{15} &
		\instbitrange{14}{12} &
		\instbitrange{11}{7} &
		\instbitrange{6}{0} \\
		\hline
		\multicolumn{1}{|c|}{csr} &
		\multicolumn{1}{c|}{rs1} &
		\multicolumn{1}{c|}{funct3} &
		\multicolumn{1}{c|}{rd} &
		\multicolumn{1}{c|}{opcode} \\
		\hline
		12 & 5 & 3 & 5 & 7 \\
		source/dest  & source & CSRRW  & dest & SYSTEM \\
		source/dest  & source & CSRRS  & dest & SYSTEM \\
		source/dest  & source & CSRRC  & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRWI & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRSI & dest & SYSTEM \\
		source/dest  & zimm[4:0]   & CSRRCI & dest & SYSTEM \\
	\end{tabular}
\end{center}
\caption{CSR Instructions}
\end{figure*}

\fi

The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values in
the CSRs and integer registers. CSRRW reads the old value of the CSR,
zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} is written to the
CSR.

The CSRRS (Atomic Read and Set CSR) instruction reads the old value of
the CSR, zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} specifies the bit
positions to be set in the CSR. Any bit that is high in \emph{rs1} will
be set in the CSR, assuming that bit can be set. The effect is a logic
OR between the old value in the CSR and the new value in \emph{rs1}.

If \emph{rs1}=X0, then the CSR is not written to.

The CSRRC (Atomic Read and Clear CSR) instruction reads the old value of
the CSR, zero-extends the value to XLEN bits, and writes it to register
\emph{rd}. The initial value in register \emph{rs1} specifies the bit
positions to be cleared in the CSR. Any bit that is high in \emph{rs1}
will be cleared in the CSR, assuming that bit can be cleared. If
\emph{rs1}=X0, then the CSR is not written to.

The CSRRWI, CSRRSI, and CSRRCI commands are similar in behavior. Except
that they update the CSR using an immediate value, instead of
referencing a source register. The immediate value is obtained by
zero-extending the 5bit \emph{zimm} field. If \emph{zimm[4:0]} is
zero, then the CSR is not written to.

\section{Illegal CSR accesses}\label{illegal-csr-accesses}

Depending on the privilege level some CSRs may not be accessible.
Attempts to access a non-existing CSR raise an illegal-instruction
exception. Attempts to access a privileged CSR or write a read-only CSR
raise an illegal-instruction exception. Machine Mode can access all
CSRs, whereas User Mode can only access a
few.

\section{Timers and Counters}\label{timers-and-counters}

\ifdefined\MARKDOWN
% Exclude Table
\else

\begin{figure*}
	\begin{center}
		\begin{tabular}{M@{}R@{}F@{}R@{}S}
			\\
			\instbitrange{31}{20} &
			\instbitrange{19}{15} &
			\instbitrange{14}{12} &
			\instbitrange{11}{7} &
			\instbitrange{6}{0} \\
			\hline
			\multicolumn{1}{|c|}{csr} &
			\multicolumn{1}{c|}{rs1} &
			\multicolumn{1}{c|}{funct3} &
			\multicolumn{1}{c|}{rd} &
			\multicolumn{1}{c|}{opcode} \\
			\hline
			12 & 5 & 3 & 5 & 7 \\
			RDCYCLE[H]   & 0 & CSRRS  & dest & SYSTEM \\
			RDTIME[H]    & 0 & CSRRS  & dest & SYSTEM \\
			RDINSTRET[H] & 0 & CSRRS  & dest & SYSTEM \\
		\end{tabular}
	\end{center}
	\caption{Time \& Counter Instructions}
\end{figure*}

\fi

The RV12 provides a number of 64-bit read-only user-level counters,
which are mapped into the 12-bit CSR address space and accessed in
32-bit pieces using CSRRS instructions.

The RDCYCLE pseudo-instruction reads the low XLEN bits of the cycle CSR
that holds a count of the number of clock cycles executed by the
processor on which the hardware thread is running from an arbitrary
start time in the past. RDCYCLEH is an RV32I-only instruction that reads
bits 63--32 of the same cycle counter. The rate at which the cycle
counter advances will depend on the implementation and operating
environment.

The RDTIME pseudo-instruction reads the low XLEN bits of the time CSR,
which counts wall-clock real time that has passed from an arbitrary
start time in the past. RDTIMEH is an RV32I-only instruction that reads
bits 63--32 of the same real-time counter. The underlying 64-bit counter
should never overflow in practice. The execution environment should
provide a means of determining the period of the real-time counter
(seconds/tick). The period must be constant. The real-time clocks of all
hardware threads in a single user application should be synchronized to
within one tick of the real-time clock. The environment should provide a
means to determine the accuracy of the clock.

The RDINSTRET pseudo-instruction reads the low XLEN bits of the instret
CSR, which counts the number of instructions retired by this hardware
thread from some arbitrary start point in the past. RDINSTRETH is an
RV32I-only instruction that reads bits 63--32 of the same instruction
counter.

In RV64I, the CSR instructions can manipulate 64-bit CSRs. In
particular, the RDCYCLE, RDTIME, and RDINSTRET pseudo-instructions read
the full 64 bits of the cycle, time, and instret counters. Hence, the
RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are not necessary and are
illegal in RV64I.

\section{CSR Listing}\label{csr-listing}

The following sections describe each of the register functions as
specifically implemented in RV12.

Note: These descriptions are derived from ``The RISC-V Instruction Set
Manual, Volume II: Privileged Architecture, Version 1.9.1", Editors
Andrew Waterman and Krste Asanović, RISC-V Foundation, November 4, 2016,
and released under the Creative Commons Attribution 4.0 International
License

\begin{longtable}[]{@{}cccl@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else

	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot

\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Information Registers}}}\tabularnewline
\fi

	0xF11 & MRO & \texttt{mvendorid} & Vendor ID\tabularnewline
	0xF12 & MRO & \texttt{marchid}   & Architecture ID\tabularnewline
	0xF13 & MRO & \texttt{mimpid}    & Implementation ID\tabularnewline
	0xF14 & MRO & \texttt{mhartid}   & Hardware thread ID\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Trap Setup}}}\tabularnewline
\fi

	0x300 & MRW & \texttt{mstatus} & Machine status register\tabularnewline
	0x301 & MRW & \texttt{misa}    & ISA and extensions\tabularnewline
	0x302 & MRW & \texttt{medeleg} & Machine exception delegation register\tabularnewline
	0x303 & MRW & \texttt{mideleg} & Machine interrupt delegation register\tabularnewline
	0x304 & MRW & \texttt{mie}     & Machine interrupt-enable register\tabularnewline
	0x305 & MRW & \texttt{mtvec}   & Machine trap-handler base address\tabularnewline
	0x7c0 & MRW & \texttt{mnmivec} & Machine non-maskable interrupt vector\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Trap Handling}}}\tabularnewline
\fi

	0x340 & MRW & \texttt{mscratch} & Scratch register for machine trap handler\tabularnewline
	0x341 & MRW & \texttt{mepc}     & Machine exception program counter\tabularnewline
	0x342 & MRW & \texttt{mcause}   & Machine trap cause\tabularnewline
	0x343 & MRW & \texttt{mbadaddr} & Machine bad address\tabularnewline
	0x344 & MRW & \texttt{mip}      & Machine interrupt pending\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Machine Counter/Timers}}}\tabularnewline
\fi

	0xB00 & MRW & \texttt{mcycle}    & Machine cycle counter\tabularnewline
	0xB02 & MRW & \texttt{minstret}  & Machine instructions-retired counter\tabularnewline
	0xB80 & MRW & \texttt{mcycleh}   & Upper 32 bits of \texttt{mcycle}, RV32I only\tabularnewline
	0xB82 & MRW & \texttt{minstreth} & Upper 32 bits of \texttt{minstret}, RV32I only\tabularnewline
\bottomrule
\caption{Machine Mode CSRs}
\label{tab:machine-csrs}
\end{longtable}

%\begin{longtable}[]{@{}cccl@{}}
%	\toprule
%	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
%	\midrule
%	
%	0xF11 & MRO & \texttt{mvendorid} & Vendor ID\tabularnewline
%	0xF12 & MRO & \texttt{marchid}   & Architecture ID\tabularnewline
%	0xF13 & MRO & \texttt{mimpid}    & Implementation ID\tabularnewline
%	0xF14 & MRO & \texttt{mhartid}   & Hardware thread ID\tabularnewline
%	
%	\bottomrule
%	\caption{Machine Information Registers}
%	\label{tab:machine-info-reg}
%\end{longtable}
%
%\begin{longtable}[]{@{}cccl@{}}
%	\toprule
%	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
%	\midrule
%	
%	0x300 & MRW & \texttt{mstatus} & Machine status register\tabularnewline
%	0x301 & MRW & \texttt{misa}    & ISA and extensions\tabularnewline
%	0x302 & MRW & \texttt{medeleg} & Machine exception delegation register\tabularnewline
%	0x303 & MRW & \texttt{mideleg} & Machine interrupt delegation register\tabularnewline
%	0x304 & MRW & \texttt{mie}     & Machine interrupt-enable register\tabularnewline
%	0x305 & MRW & \texttt{mtvec}   & Machine trap-handler base address\tabularnewline
%	0x7c0 & MRW & \texttt{mnmivec} & Machine non-maskable interrupt vector\tabularnewline
%	
%	\bottomrule
%	\caption{Machine Trap Setup}
%	\label{tab:machine-trap-setup}
%\end{longtable}
%
%\begin{longtable}[]{@{}cccl@{}}
%	\toprule
%	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
%	\midrule
%	
%	0x340 & MRW & \texttt{mscratch} & Scratch register for machine trap handler\tabularnewline
%	0x341 & MRW & \texttt{mepc}     & Machine exception program counter\tabularnewline
%	0x342 & MRW & \texttt{mcause}   & Machine trap cause\tabularnewline
%	0x343 & MRW & \texttt{mbadaddr} & Machine bad address\tabularnewline
%	0x344 & MRW & \texttt{mip}      & Machine interrupt pending\tabularnewline
%	
%	\bottomrule
%	\caption{Machine Trap Handling}
%	\label{tab:machine-trap-handling}
%\end{longtable}
%
%\begin{longtable}[]{@{}cccl@{}}
%	\toprule
%	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
%	\midrule
%
%	0xB00 & MRW & \texttt{mcycle}    & Machine cycle counter\tabularnewline
%	0xB02 & MRW & \texttt{minstret}  & Machine instructions-retired counter\tabularnewline
%	0xB80 & MRW & \texttt{mcycleh}   & Upper 32 bits of \texttt{mcycle}, RV32I only\tabularnewline
%	0xB82 & MRW & \texttt{minstreth} & Upper 32 bits of \texttt{minstret}, RV32I only\tabularnewline
%	\bottomrule
%
%	\caption{Machine Counter/Timers}
%	\label{tab:machine-counter-timer}
%\end{longtable}




\begin{longtable}[]{@{}cccl@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else
	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot
\fi

\ifdefined\MARKDOWN
% Skip Row
\else
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Supervisor Trap Handling}}}\tabularnewline
\fi

	0x100 & SRW & \texttt{sstatus} & Supervisor status register\tabularnewline
	0x102 & SRW & \texttt{sedeleg} & Supervisor exception delegation register\tabularnewline
	0x103 & SRW & \texttt{sideleg} & Supervisor interrupt delegation register\tabularnewline
	0x104 & SRW & \texttt{sie}     & Supervisor interrupt-enable register\tabularnewline
	0x105 & SRW & \texttt{stvec}   & Supervisor trap handler base address\tabularnewline

\ifdefined\MARKDOWN
% Skip Row
\else	
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{Supervisor Trap Handling}}}\tabularnewline

\fi
	0x140 & SRW & \texttt{sscratch} & Scratch register for trap handler\tabularnewline
	0x141 & SRW & \texttt{sepc}     & Supervisor exception program counter\tabularnewline
	0x142 & SRO & \texttt{scause}   & Supervisor trap cause\tabularnewline
	0x143 & SRO & \texttt{sbadaddr} & Supervisor bad address\tabularnewline
	0x144 & SRW & \texttt{sip}      & Supervisor interrupt pending register\tabularnewline
	\bottomrule
	\caption{Supervisor Mode CSRs}
	\label{tab:supervisor-csrs}
\end{longtable}


\begin{longtable}[]{@{}cccl@{}}
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule

\ifdefined\MARKDOWN
	\endhead
\else

	\endfirsthead
	\multicolumn{4}{c}{{(Continued from previous page)}} \\
	\toprule
	\textbf{Address} & \textbf{Privilege} & \textbf{Name} & \textbf{Description}\tabularnewline
	\midrule
	\endhead
	\midrule \multicolumn{4}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
	\endfoot
	\endlastfoot
\fi

\ifdefined\MARKDOWN
% Skip Row
\else	
	\rowcolor{rltable}\multicolumn{4}{c}{\emph{\textbf{User Counter / Timers}}}\tabularnewline
\fi

	0xC00 & URO & \texttt{cycle} & Cycle counter for \texttt{RDCYCLE} instruction\tabularnewline
	0xC02 & URO & \texttt{instret} & Instruction-retire counter for \texttt{RDINSTRET}\tabularnewline
	0xC80 & URO & \texttt{cycleh} & Upper 32bits of \texttt{cycle}, RV32I only\tabularnewline
	0xC82 & URO & \texttt{instret} h& Upper 32bit of \texttt{instret}, RV32I only\tabularnewline
	\bottomrule
	\caption{User Mode CSRs}
	\label{tab:user-csrs}
\end{longtable}

\section{Machine Level CSRs}\label{machine-level-csrs}

In addition to the machine-level CSRs described in this section, M-mode
can access all CSRs at lower privilege levels.

\subsection{Machine ISA Register (\texttt{misa})}\label{machine-isa-register-misa}

The \texttt{misa} register is an XLEN-bit WARL read-write register reporting the
ISA supported by the hart.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}c@{}J}
				\instbitrange{XLEN-1}{XLEN-2} &
				\instbitrange{XLEN-3}{26} &
				\instbitrange{25}{0} \\
				\hline
				\multicolumn{1}{|c|}{Base (\warl)} &
				\multicolumn{1}{c|}{\wiri} &
				\multicolumn{1}{c|}{Extensions (\warl)} \\
				\hline
				2 & XLEN-28 & 26 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine ISA register (\texttt{misa}).}
	\label{fig:misareg}
\end{figure*}

\fi

The extensions field encodes the presence of the standard extensions,
with a single bit per letter of the alphabet (bit 0 encodes the presence
of extension ``A'', bit 1 encodes the presence of extension ``B'',
through to bit 25 that encodes the presence of extension ``Z'').

The ``I'' bit will be set for RV32I and RV64I base ISAs, and the ``E''
bit will be set for RV32E.

The Base field encodes the native base integer ISA width as shown:

\begin{longtable}[]{@{}cc@{}}
\toprule
Value & Description\tabularnewline
\midrule
\endhead
1 & 32\tabularnewline
2 & 64\tabularnewline
\bottomrule
\caption{Supported \texttt{misa} values}
\label{tab:misa-values}
\end{longtable}

\subsection{Vendor ID Register (\texttt{mvendorid})}\label{vendor-id-register-mvendorid}

The \texttt{mvendorid} read-only register is an XLEN-bit register encoding the
manufacturer of the device.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Vendor} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Vendor ID register (\texttt{mvendorid}).}
	\label{fig:mvendorreg}
\end{figure*}

\fi

Non-Zero vendor IDs will be allocated by the RISC-V Foundation.

\subsection{Architecture ID Register
(\texttt{marchid})}\label{architecture-id-register-marchid}

The \texttt{marched} CSR is an XLEN-bit read-only register encoding the base
microarchitecture of the hart. For the RV12 CPU this is defined as:

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Architecture ID} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Architecture ID register (\texttt{marchid}).}
	\label{fig:marchreg}
\end{figure*}

\fi

Note: Open-source project architecture IDs are allocated globally by the
RISC-V Foundation, and have non-zero architecture IDs with a zero
most-significant-bit (MSB). Commercial architecture IDs are allocated by
each commercial vendor independently and have the MSB set.

\subsection{Implementation ID Register
(\texttt{mimpid})}\label{implementation-id-register-mimpid}

The \texttt{mimpid} read-only register provides hardware version information for
the CPU. In the Roa Logic implementation, the 2 least significant bytes
encode the major and minor code revisions.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Implementation}  \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Implementation ID register (\texttt{mimpid}).}
	\label{fig:mimpidreg}
\end{figure*}

\fi

The \texttt{mimpid} register is an XLEN size register, but the RV12 only
implements the lower 32 bits. For an RV64 implementation the MSBs are
zero extended.

\subsection{Hardware Thread ID Register
(\texttt{mhartid})}\label{hardware-thread-id-register-mhartid}

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Hart ID}\\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Hart ID register (\texttt{mhartid}).}
	\label{fig:mhartidreg}
\end{figure*}

\fi

The \texttt{mhartid} read-only register indicates the hardware thread that is
running the code. The RV12 implements a single thread, therefore this
register always reads zero.

\subsection{Machine Status Register
(\texttt{mstatus})}\label{machine-status-register-mstatus}

The \texttt{mstatus} register is an \texttt{XLEN}-bit read/write register that keeps track
of and controls the \emph{hart's} current operating state.

\subsubsection{Privilege and Global Interrupt-Enable Stack in mstatus register}

Interrupt-enable bits, \texttt{MIE}, \texttt{SIE}, and \texttt{UIE}, are provided for each
privilege mode. These bits are primarily used to guarantee atomicity
with respect to interrupt handlers at the current privilege level. When
a hart is executing in privilege mode \emph{x}, interrupts are enabled
when \texttt{\emph{x}IE=1}. Interrupts for lower privilege modes are always
disabled, whereas interrupts for higher privilege modes are always
enabled. Higher-privilege-level code can use separate per-interrupt
enable bits to disable selected interrupts before ceding control to a
lower privilege level.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{cEccccccc}
				\\
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{29} &
				\instbitrange{28}{24} &
				\instbitrange{23}{20} &
				\instbit{19} &
				\instbit{18} &
				\instbit{17} &
				\instbitrange{16}{15} &
				\\
				\hline
				\multicolumn{1}{|c|}{SD} &
				\multicolumn{1}{c|}{\wpri} &
				\multicolumn{1}{c|}{VM[4:0]\,(\warl)} & 
				\multicolumn{1}{c|}{\wpri} &
				\multicolumn{1}{c|}{MXR} &
				\multicolumn{1}{c|}{PUM} &
				\multicolumn{1}{c|}{MPRV} &
				\multicolumn{1}{c|}{XS[1:0]} &
				\\
				\hline
				1 & XLEN-30 & 5 & 4 & 1 & 1 & 1 & 2 & \\
			\end{tabular}
			\begin{tabular}{ccccccccccccc}
				\\
				&
				\instbitrange{14}{13} &
				\instbitrange{12}{11} &
				\instbitrange{10}{9} &
				\instbit{8} &
				\instbit{7} &
				\instbit{6} &
				\instbit{5} &
				\instbit{4} &
				\instbit{3} &
				\instbit{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				&
				\multicolumn{1}{|c|}{FS[1:0]} &
				\multicolumn{1}{c|}{MPP[1:0]} &
				\multicolumn{1}{c|}{HPP[1:0]} &
				\multicolumn{1}{c|}{SPP} &
				\multicolumn{1}{c|}{MPIE} &
				\multicolumn{1}{c|}{HPIE} &
				\multicolumn{1}{c|}{SPIE} &
				\multicolumn{1}{c|}{UPIE} &
				\multicolumn{1}{c|}{MIE} &
				\multicolumn{1}{c|}{HIE} &
				\multicolumn{1}{c|}{SIE} &
				\multicolumn{1}{c|}{UIE} \\
				\hline
				& 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine-mode status register (\texttt{mstatus}).}
	\label{fig:mstatusreg}
\end{figure*}

\fi

The \texttt{MRET}, \texttt{SRET}, or \texttt{URET} instructions are used to return from traps in M-mode, S-mode, or U-mode respectively. When executing an \texttt{\emph{x}RET}
instruction, supposing \texttt{\emph{x}PP} holds the value \texttt{\emph{y}}, \texttt{\emph{y}IE}
is set to \texttt{\emph{x}PIE}; the privilege mode is changed to \texttt{\emph{y}};
\texttt{\emph{x}PIE} is set to 1; and \texttt{\emph{x}PP} is set to U.

\subsubsection{Memory Privilege in \texttt{mstatus} Register
}\label{memory-privilege-in-mstatus-register}

The \texttt{MPRV} bit modifies the privilege level at which loads and stores
execute. When \texttt{MPRV}='0', translation and protection behave as normal.
When \texttt{MPRV}='1', data memory addresses are translated and protected as
though \texttt{PRV} were set to the current value of the \texttt{PRV1} field. Instruction
address-translation and protection are unaffected. When an exception
occurs, \texttt{MPRV} is reset to 0.

\subsubsection{Virtualization Management \& Context Extension Fields in
\texttt{mstatus} Register
}\label{virtualization-management-context-extension-fields-in-mstatus-register}

Virtualization and Context Extensions are not supported by the RV12 v1.0
implementation. The value of these fields will therefore be permanently
set to 0.

\subsection{Machine Delegation Registers
(\texttt{medeleg} \& \texttt{mideleg})} \label{machine-exception-interrupt-delegation-registers-medeleg-mideleg}

Individual read/write bits within \texttt{medeleg} and \texttt{mideleg} registers indicate
that lower privilege levels should directly process certain exceptions
and interrupts.

When a trap is delegated to a less-privileged mode \texttt{\emph{x}}, the
\texttt{\emph{x}cause} register is written with the trap cause; the \texttt{\emph{x}epc}
register is written with the virtual address of the instruction that
took the trap; the \texttt{\emph{x}PP} field of \texttt{mstatus} is written with the
active privilege mode at the time of the trap; the \texttt{\emph{x}PIE} field of
\texttt{mstatus} is written with the value of the active interrupt-enable bit at
the time of the trap; and the \texttt{\emph{x}IE} field of \texttt{mstatus} is cleared.
The \texttt{mcause} and \texttt{mepc} registers and the \texttt{MPP} and \texttt{MPIE} fields of \texttt{mstatus} are not written.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}U}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Synchronous Exceptions (\warl)} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Exception Delegation Register \texttt{medeleg}.}
	\label{fig:medelegreg}
\end{figure}

\fi

\texttt{medeleg} has a bit position allocated for every synchronous exception with the index of the bit position equal to the
value returned in the \texttt{mcause} register (I.e. setting bit 8 allows
user-mode environment calls to be delegated to a lower-privilege trap
handler). 

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}U}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupts (\warl)} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Exception Delegation Register \texttt{mideleg}.}
	\label{fig:midelegreg}
\end{figure}

\fi

\texttt{mideleg} holds trap delegation bits for individual interrupts, with the
layout of bits matching those in the \texttt{mip} register (I.e. \texttt{STIP} interrupt
delegation control is located in bit 5).

\subsection{Machine Interrupt Registers (\texttt{mie},
\texttt{mip})}\label{machine-interrupt-registers-mie-mip}

The \texttt{mip} register is an \texttt{XLEN}-bit read/write register containing
information on pending interrupts, while \texttt{mie} is the corresponding
\texttt{XLEN}-bit read/write register containing interrupt enable bits. Only the
bits corresponding to lower-privilege software interrupts (\texttt{USIP}, \texttt{SSIP})
and timer interrupts (\texttt{UTIP}, \texttt{STIP}) in \texttt{mip} are writable through this CSR address; the remaining bits are read-only.

Restricted views of the \texttt{mip} and \texttt{mie} registers appear as the \texttt{sip/sie}, and
\texttt{uip/uie} registers in S-mode, and U-mode respectively. If an interrupt is
delegated to privilege mode \texttt{\emph{x}} by setting a bit in the \texttt{mideleg}
register, it becomes visible in the \texttt{\emph{x}ip} register and is maskable
using the \texttt{\emph{x}ie}register. Otherwise, the corresponding bits in
\texttt{\emph{x}ip} and \texttt{\emph{x}}ie appear to be hardwired to zero.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{Ycccccccccccc}
				\instbitrange{XLEN-1}{12} &
				\instbit{11} &
				\instbit{10} &
				\instbit{9} &
				\instbit{8} &
				\instbit{7} &
				\instbit{6} &
				\instbit{5} &
				\instbit{4} &
				\instbit{3} &
				\instbit{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{\wiri} &
				\multicolumn{1}{c|}{MEIP} &
				\multicolumn{1}{c|}{HEIP} &
				\multicolumn{1}{c|}{SEIP} &
				\multicolumn{1}{c|}{UEIP} &
				\multicolumn{1}{c|}{MTIP} &
				\multicolumn{1}{c|}{HTIP} &
				\multicolumn{1}{c|}{STIP} &
				\multicolumn{1}{c|}{UTIP} &
				\multicolumn{1}{c|}{MSIP} &
				\multicolumn{1}{c|}{HSIP} &
				\multicolumn{1}{c|}{SSIP} &
				\multicolumn{1}{c|}{USIP} \\
				\hline
				XLEN-12 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine interrupt-pending register (\texttt{mip}).}
	\label{fig:mipreg}
\end{figure*}

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{Ycccccccccccc}
				\instbitrange{XLEN-1}{12} &
				\instbit{11} &
				\instbit{10} &
				\instbit{9} &
				\instbit{8} &
				\instbit{7} &
				\instbit{6} &
				\instbit{5} &
				\instbit{4} &
				\instbit{3} &
				\instbit{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{\wpri} &
				\multicolumn{1}{c|}{MEIE} &
				\multicolumn{1}{c|}{HEIE} &
				\multicolumn{1}{c|}{SEIE} &
				\multicolumn{1}{c|}{UEIE} &
				\multicolumn{1}{c|}{MTIE} &
				\multicolumn{1}{c|}{HTIE} &
				\multicolumn{1}{c|}{STIE} &
				\multicolumn{1}{c|}{UTIE} &
				\multicolumn{1}{c|}{MSIE} &
				\multicolumn{1}{c|}{HSIE} &
				\multicolumn{1}{c|}{SSIE} &
				\multicolumn{1}{c|}{USIE} \\
				\hline
				XLEN-12 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine interrupt-enable register (\texttt{mie}).}
	\label{fig:miereg}
\end{figure*}

\fi

The \texttt{MTIP}, \texttt{STIP}, \texttt{UTIP} bits correspond to timer interrupt-pending bits for
machine, supervisor, and user timer interrupts, respectively. The \texttt{MTIP}
bit is read-only and is cleared by writing to the memory-mapped
machine-mode timer compare register. The \texttt{UTIP} and \texttt{STIP} bits may be
written by M-mode software to deliver timer interrupts to lower
privilege levels. User and supervisor software may clear the \texttt{UTIP} and
\texttt{STIP} bits with calls to the AEE or SEE respectively.

There is a separate timer interrupt-enable bit, named \texttt{MTIE}, \texttt{STIE}, and
\texttt{UTIE} for M-mode, S-mode, and U-mode timer interrupts respectively.

Each lower privilege level has a separate software interrupt-pending bit
(\texttt{SSIP}, \texttt{USIP}), which can be both read and written by CSR accesses from
code running on the local hart at the associated or any higher privilege
level. The machine-level \texttt{MSIP} bits are written by accesses to
memory-mapped control registers, which are used by remote harts to
provide machine-mode interprocessor interrupts. Interprocessor
interrupts for lower privilege levels are implemented through ABI or SBI
calls to the AEE or SEE respectively, which might ultimately result in a
machine- mode write to the receiving hart's \texttt{MSIP} bit. A hart can write
its own \texttt{MSIP} bit using the same memory-mapped control register.

The \texttt{MEIP}, \texttt{SEIP}, \texttt{UEIP} bits correspond to external interrupt-pending bits for machine, supervisor, and user external interrupts, 
respectively. These bits are read-only and are set and cleared by a platform-specific
interrupt controller. There is a separate external interrupt-enable bit,
named \texttt{MEIE}, \texttt{SEIE}, and \texttt{UEIE} for M-mode, S-mode, 
and U-mode external interrupts respectively.

An interrupt\texttt{ \emph{i}} will be taken if bit \texttt{\emph{i}} is set in 
both \texttt{mip} and \texttt{mie}, and if interrupts are globally enabled. By default,
M-mode interrupts are globally enabled if the hart's current privilege mode is
less than M, or if the current privilege mode is M and the \texttt{MIE} bit in
the \texttt{mstatus} register is set. If bit \texttt{\emph{i}} in \texttt{mideleg} is 
set, however, interrupts are considered to be globally enabled if the hart's current
privilege mode equals the delegated privilege mode (S, or U) and that
mode's interrupt enable bit (\texttt{SIE} or \texttt{UIE} in \texttt{mstatus}) is 
set, or if the current privilege mode is less than the delegated privilege mode.

Multiple simultaneous interrupts and traps at the same privilege level
are handled in the following decreasing priority order: external
interrupts, software interrupts, timer interrupts, and then finally any
synchronous traps.

\subsection{Machine Trap-Handler Base Address Register
(\texttt{mtvec})}\label{machine-trap-handler-base-address-register-mtvec}

The mtvec register is an XLEN-bit read/write register that holds the
base address of the M-mode trap vector.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J@{}F}
				\instbitrange{XLEN-1}{2} &
				\instbitrange{1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Trap-Vector Base Address (\warl)} & 
				\multicolumn{1}{c|}{0} \\
				\hline
				XLEN-2 & 2 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine trap-vector base-address register (\texttt{mtvec}).}
	\label{fig:mtvecreg}
\end{figure*}

\fi

All traps into machine mode cause the pc to be set to the value in
\texttt{mtvec}. Additional trap vector entry points can be defined by
implementations to allow more rapid identification and service of
certain trap causes.

\subsection{Machine Non-Maskable Interrupt Vector
(\texttt{mnmivec})}\label{machine-non-maskable-interrupt-vector-mnmivec}

The mnmivec register is an XLEN-bit read/write register that holds the
base address of the non-maskable interrupt trap vector. When an
exception occurs, the pc is set to mnmivec.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{mnmivec} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Non-Maskable Interrupt Vector}
	\label{fig:mnmivecreg}
\end{figure}

\fi

\subsection{Machine Trap Handler Scratch Register
(\texttt{mscratch})}\label{machine-trap-handler-scratch-register-mscratch}

The \texttt{mscratch} register is an XLEN-bit read/write register dedicated for
use by machine mode. It is used to hold a pointer to a machine-mode
hart-local context space and swapped with a user register upon entry to
an M-mode trap handler.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{mscratch} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine-mode scratch register.}
	\label{fig:mscratchreg}
\end{figure}

\fi

\subsection{Machine Exception Program Counter Register
(\texttt{mepc})}\label{machine-exception-program-counter-register-mepc}

\texttt{mepc} is an XLEN-bit read/write register. The two low bits
(mepc[1:0]) are always zero.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{mepc} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine exception program counter register.}
	\label{fig:mepcreg}
\end{figure}

\fi

When a trap is taken, \texttt{mepc} is written with the virtual address of the
instruction that encountered the exception.

\subsection{Machine Trap Cause Register
(\texttt{mcause})}\label{machine-trap-cause-register-mcause}

The \texttt{mcause} register is an XLEN-bit read-write register. The Interrupt
bit is set if the exception was caused by an interrupt. The Exception
Code field contains a code identifying the last exception. The remaining
center bits will read zero

\ifdefined\MARKDOWN
% Skip Row
\else
\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}U}
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupt} &
				\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
				\hline
				1 & XLEN-1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine Cause register \texttt{mcause}.}
	\label{fig:mcausereg}
\end{figure*}
\fi

\ifdefined\MARKDOWN
See PDF Datasheet for further details
\else
Table \ref{tab:mcause-reg-values} below lists the possible machine-level exception codes.

\begin{longtable}[]{@{}ccl@{}}
\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endfirsthead
\multicolumn{3}{c}{{(Continued from previous page)}} \\

\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endhead

\midrule \multicolumn{3}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
\endfoot

\endlastfoot
1 & 0 & User software interrupt\tabularnewline
1 & 1 & Supervisor software interrupt\tabularnewline
1 & 2 & \emph{Reserved}\tabularnewline
1 & 3 & Machine software interrupt\tabularnewline
1 & 4 & User timer interrupt\tabularnewline
1 & 5 & Supervisor timer interrupt\tabularnewline
1 & 6 & \emph{Reserved}\tabularnewline
1 & 7 & Machine timer interrupt\tabularnewline
1 & 8 & User external interrupt\tabularnewline
1 & 9 & Supervisor external interrupt\tabularnewline
1 & 10 & \emph{Reserved}\tabularnewline
1 & 11 & Machine external interrupt\tabularnewline
1 & $\geqslant$12 & Reserved\tabularnewline
\midrule
0 & 0 & Instruction address misaligned\tabularnewline
0 & 1 & Instruction access fault\tabularnewline
0 & 2 & Illegal Instruction\tabularnewline
0 & 3 & Breakpoint\tabularnewline
0 & 4 & Load address misaligned\tabularnewline
0 & 5 & Load access fault\tabularnewline
0 & 6 & Store/AMO address misaligned\tabularnewline
0 & 7 & Store/AMO access fault\tabularnewline
0 & 8 & Environment call from U-mode\tabularnewline
0 & 9 & Environment call from S-mode\tabularnewline
0 & 10 & \emph{Reserved}\tabularnewline
0 & 11 & Environment call from M-mode\tabularnewline
0 & $\geqslant$12 & \emph{Reserved}\tabularnewline
\bottomrule
\caption{Machine Cause Register Values}
\label{tab:mcause-reg-values}
\end{longtable}

\fi

\subsection{Machine Bad Address Register
(\texttt{mbadaddr})}\label{machine-bad-address-register-mbadaddr}

\texttt{mbadaddr} is an XLEN-bit read-write register. When a hardware breakpoint
is triggered, or an instruction-fetch, load, or store address-misaligned
or access exception occurs, \texttt{mbadaddr} is written with the faulting
address. \texttt{mbadaddr} is not modified for other exceptions.

\ifdefined\MARKDOWN
% Exclude Table
\else
\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{mbadaddr} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Machine bad address register.}
	\label{fig:mbadaddrreg}
\end{figure}
\fi

For instruction-fetch access faults with variable-length instructions,
\texttt{mbadaddr} will point to the portion of the instruction that caused the
fault while \texttt{mepc} will point to the beginning of the instruction.

\subsection{Machine Cycle Counter (mcycle,
\texttt{mcycleh})}\label{machine-cycle-counter-mcycle-mcycleh}

The \texttt{mcycle} CSR holds a count of the number of cycles the hart has
executed since some arbitrary time in the past. The \texttt{mcycle} register has
64-bit precision on all RV32 and RV64 systems.

On RV32 only, reads of the \texttt{mcycle} CSR returns the low 32 bits, while
reads of the \texttt{mcycleh} CSR returns bits 63--32.

\subsection{Machine Instructions-Retired counter (minstret,
\texttt{minstreth})}\label{machine-instructions-retired-counter-minstret-minstreth}

The \texttt{minstret} CSR holds a count of the number of instructions the hart
has retired since some arbitrary time in the past. The \texttt{minstret} register
has 64-bit precision on all RV32 and RV64 systems.

On RV32 only, reads of the \texttt{minstret} CSR returns the low 32 bits, while
reads of the \texttt{minstreth} CSR returns bits 63--32.

\section{Supervisor Mode CSRs}\label{supervisor-mode-csrs}

\subsection{Supervisor Status Register (sstatus)
}\label{supervisor-status-register-sstatus}

The sstatus register is an XLEN-bit read/write register. The sstatus register 
keeps track of the processor's current operating state.

\ifdefined\MARKDOWN
% Skip Table
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{cYccccWcWccWcc}
				\\
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{19} &
				\instbit{18} &
				\instbit{17} &
				\instbitrange{16}{15} &
				\instbitrange{14}{13} &
				\instbitrange{12}{9} &
				\instbit{8} &
				\instbitrange{7}{6} &
				\instbit{5} &
				\instbit{4} &
				\instbitrange{3}{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{SD} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{PUM} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{XS[1:0]} &
				\multicolumn{1}{c|}{FS[1:0]} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SPP} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SPIE} &
				\multicolumn{1}{c|}{UPIE} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SIE}  &
				\multicolumn{1}{c|}{UIE}
				\\
				\hline
				1 & XLEN-20 & 1 & 1 & 2 & 2 & 4 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor-mode status Register.}
	\label{fig:sstatusreg}
\end{figure*}

\fi

The \texttt{SPP} bit indicates the privilege level at which a \emph{hart} was
executing before entering supervisor mode. When a trap is taken, \texttt{SPP} is
set to 0 if the trap originated from user mode, or 1 otherwise. When an
\texttt{SRET} instruction is executed to return from the trap handler, the
privilege level is set to user mode if the \texttt{SPP} bit is 0, or supervisor
mode if the \texttt{SPP} bit is 1; \texttt{SPP} is then set to 0.

The \texttt{SIE} bit enables or disables all interrupts in supervisor mode. When
\texttt{SIE} is clear, interrupts are not taken while in supervisor mode. When
the \emph{hart} is running in user-mode, the value in \texttt{SIE} is ignored,
and supervisor-level interrupts are enabled. The supervisor can disable
indivdual interrupt sources using the \texttt{sie} register.

The \texttt{SPIE} bit indicates whether interrupts were enabled before entering
supervisor mode. When a trap is taken into supervisor mode, \texttt{SPIE} is set
to either \texttt{SIE} or \texttt{UIE} depending on whether the trap was taken in
supervisor or user mode respectively, and \texttt{SIE} is set to 0. When an \texttt{SRET}
instruction is executed, if \texttt{SPP=S}, then \texttt{SIE} is set to \texttt{SPIE}; or if \texttt{SPP=U},
then \texttt{UIE} is set to \texttt{SPIE}. In either case, \texttt{SPIE} is then set to 1.

The \texttt{UIE} bit enables or disables user-mode interrupts. User-level
interrupts are enabled only if \texttt{UIE} is set and the \emph{hart} is running
in user-mode. The \texttt{UPIE} bit indicates whether user-level interrupts were
enabled prior to taking a user-level trap. When a \texttt{URET} instruction is
executed, \texttt{UIE} is set to \texttt{UPIE}, and \texttt{UPIE} is set to 1.

\subsubsection{Memory Privilege in \texttt{sstatus} Register
}\label{memory-privilege-in-sstatus-register}

The \texttt{PUM} (Protect User Memory) bit modifies the privilege with which
S-mode loads, stores, and instruction fetches access virtual memory.
When \texttt{PUM=0}, translation and protection behave as normal. When \texttt{PUM=1},
S-mode memory accesses to pages that are accessible by U-mode will fault. \texttt{PUM} has no effect when executing in U-mode.

\subsection{Supervisor Trap Delegation Registers (\texttt{sedeleg},
\texttt{sideleg})}\label{supervisor-trap-delegation-registers-sedeleg-sideleg}

The machine exception delegation register (\texttt{sedeleg}) and machine
interrupt delegation register (\texttt{sideleg}) are XLEN-bit read/write
registers.

\subsection{Supervisor Interrupt Registers (sip, sie)}

The \texttt{sip} register is an XLEN-bit read/write register containing
information on pending interrupts; \texttt{sie} is the corresponding XLEN-bit
read/write register containing interrupt enable bits.

\ifdefined\MARKDOWN
% Skip 
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{EccFccFcc}
				\instbitrange{XLEN-1}{10} &
				\instbit{9} &
				\instbit{8} &
				\instbitrange{7}{6} &
				\instbit{5} &
				\instbit{4} &
				\instbitrange{3}{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{0} &
				\multicolumn{1}{c|}{SEIP} &
				\multicolumn{1}{c|}{UEIP} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{STIP} &
				\multicolumn{1}{c|}{UTIP} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SSIP} &
				\multicolumn{1}{c|}{USIP} \\
				\hline
				XLEN-10 & 1 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor interrupt-pending register (\texttt{sip}).}
	\label{fig:sipreg}
\end{figure*}

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\setlength{\tabcolsep}{4pt}
			\begin{tabular}{EccFccFcc}
				\instbitrange{XLEN-1}{10} &
				\instbit{9} &
				\instbit{8} &
				\instbitrange{7}{6} &
				\instbit{5} &
				\instbit{4} &
				\instbitrange{3}{2} &
				\instbit{1} &
				\instbit{0} \\
				\hline
				\multicolumn{1}{|c|}{0} &
				\multicolumn{1}{c|}{SEIE} &
				\multicolumn{1}{c|}{UEIE} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{STIE} &
				\multicolumn{1}{c|}{UTIE} &
				\multicolumn{1}{c|}{0} &
				\multicolumn{1}{c|}{SSIE} &
				\multicolumn{1}{c|}{USIE} \\
				\hline
				XLEN-10 & 1 & 1 & 2 & 1 & 1 & 2 & 1 & 1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor interrupt-enable register (\texttt{sie}).}
	\label{fig:siereg}
\end{figure*}

\fi

Three types of interrupts are defined: software interrupts, timer
interrupts, and external interrupts. A supervisor-level software
interrupt is triggered on the current \emph{hart} by writing 1 to its
supervisor software interrupt-pending (\texttt{SSIP}) bit in the \texttt{sip} register. A
pending supervisor-level software interrupt can be cleared by writing 0
to the \texttt{SSIP} bit in \texttt{sip}. Supervisor-level software interrupts are
disabled when the \texttt{SSIE} bit in the \texttt{sie} register is clear.

Interprocessor interrupts are sent to other harts by means of \emph{SBI}
calls, which will ultimately cause the \texttt{SSIP} bit to be set in the
recipient \emph{hart's} \texttt{sip} register.

A user-level software interrupt is triggered on the current \emph{hart}
by writing 1 to its user software interrupt-pending (\texttt{USIP}) bit in the
sip register. A pending user-level software interrupt can be cleared by
writing 0 to the \texttt{USIP} bit in \texttt{sip}. User-level software interrupts are
disabled when the \texttt{USIE} bit in the \texttt{sie} register is clear.

All bits besides \texttt{SSIP} and \texttt{USIP} in the \texttt{sip} register are read-only.

A supervisor-level timer interrupt is pending if the \texttt{STIP} bit in the \texttt{sip}
register is set. Supervisor-level timer interrupts are disabled when the
\texttt{STIE} bit in the \texttt{sie} register is clear. An \emph{SBI} call to the SEE may
be used to clear the pending timer interrupt.

A user-level timer interrupt is pending if the \texttt{UTIP} bit in the \texttt{sip}
register is set. User-level timer interrupts are disabled when the \texttt{UTIE}
bit in the \texttt{sie} register is clear. If user-level interrupts are
supported, the \emph{ABI} should provide a facility for scheduling timer
interrupts in terms of real-time counter values.

A supervisor-level external interrupt is pending if the \texttt{SEIP} bit in the
\texttt{sip} register is set. Supervisor-level external interrupts are disabled
when the \texttt{SEIE} bit in the \texttt{sie} register is clear. The \emph{SBI} should
provide facilities to mask, unmask, and query the cause of external
interrupts.

A user-level external interrupt is pending if the \texttt{UEIP} bit in the \texttt{sip}
register is set. User-level external interrupts are disabled when the
UEIE bit in the \texttt{sie} register is clear.

\subsection{Supervisor Trap Vector Register
(\texttt{stvec})}\label{supervisor-trap-vector-register-stvec}

The \texttt{stvec} register is an XLEN-bit read/write register that holds the
base address of the S-mode trap vector. When an exception occurs, the pc
is set to \texttt{stvec}. The \texttt{stvec} register is always aligned to a 4-byte
boundary.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{J@{}F}
				\instbitrange{XLEN-1}{2} &
				\instbitrange{1}{0} \\
				\hline
				\multicolumn{1}{|c|}{Trap-Vector Base Address (\warl)} & 
				\multicolumn{1}{c|}{0} \\
				\hline
				XLEN-2 & 2 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor trap-vector base-address register (\texttt{mtvec}).}
	\label{fig:stvecreg}
\end{figure*}

\fi

\subsection{Supervisor Scratch Register (\texttt{sscratch})
}\label{supervisor-scratch-register-sscratch}

The \texttt{sscratch} register is an XLEN-bit read/write register, dedicated for
use by the supervisor. Typically, \texttt{sscratch} is used to hold a pointer to
the hart-local supervisor context while the hart is executing user code.
At the beginning of a trap handler, \texttt{sscratch} is swapped with a user
register to provide an initial working register.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{sscratch} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor Scratch Register.}
	\label{fig:sscratchreg}
\end{figure}

\fi

\subsection{Supervisor Exception Program Counter
(\texttt{sepc})}\label{supervisor-exception-program-counter-sepc}

\texttt{sepc} is an XLEN-bit read/write register formatted as shown in Figure
7‑24. The low bit of \texttt{sepc} (\texttt{sepc{[}0{]}}) is always zero. On
implementations that do not support instruction-set extensions with
16-bit instruction alignment, the two low bits (\texttt{sepc{[}1:0{]}}) are
always zero. When a trap is taken, \texttt{sepc} is written with the virtual
address of the instruction that encountered the exception.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{sepc} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor exception program counter register.}
	\label{epcreg}
\end{figure}

\fi

\subsection{Supervisor Cause Register (\texttt{scause})
}\label{supervisor-cause-register-scause}

The \texttt{scause} register is an XLEN-bit read-only register. The Interrupt bit
is set if the exception was caused by an interrupt. The Exception Code
field contains a code identifying the last exception.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure*}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{c@{}U}
				\instbit{XLEN-1} &
				\instbitrange{XLEN-2}{0} \\
				\hline
				\multicolumn{1}{|c|}{Interrupt} &
				\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
				\hline
				1 & XLEN-1 \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor Cause register \texttt{scause}.}
	\label{scausereg}
\end{figure*}

Table \ref{tab:scause-reg-values} below lists the possible exception codes for the current supervisor ISAs.
\fi

\begin{longtable}[]{@{}ccl@{}}
\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule

\ifdefined\MARKDOWN
\endhead
\else

\endfirsthead
\multicolumn{3}{c}{{(Continued from previous page)}} \\

\toprule
Interrupt & Exception Code & Description\tabularnewline
\midrule
\endhead

\midrule \multicolumn{3}{c}{{\tablename\ \thetable{} continued on next page\ldots}} \\
\endfoot

\endlastfoot

\fi

1 & 0 & User software interrupt\tabularnewline
1 & 1 & Supervisor software interrupt\tabularnewline
1 & 2-3 & \emph{Reserved}\tabularnewline
1 & 4 & User timer interrupt\tabularnewline
1 & 5 & Supervisor timer interrupt\tabularnewline
1 & 6-7 & \emph{Reserved}\tabularnewline
1 & 8 & User external interrupt\tabularnewline
1 & 9 & Supervisor external interrupt\tabularnewline
1 & $\leqslant$10 & \emph{Reserved}\tabularnewline
\midrule
0 & 0 & Instruction address misaligned\tabularnewline
0 & 1 & Instruction access fault\tabularnewline
0 & 2 & Illegal Instruction\tabularnewline
0 & 3 & Breakpoint\tabularnewline
0 & 4 & \emph{Reserved}\tabularnewline
0 & 5 & Load access fault\tabularnewline
0 & 6 & AMO address misaligned\tabularnewline
0 & 7 & Store/AMO access fault\tabularnewline
0 & 8 & Environment call\tabularnewline
0 & $\leqslant$9 & \emph{Reserved}\tabularnewline
\bottomrule
\caption{Supervisor Cause Register Values}
\label{tab:scause-reg-values}
\end{longtable}

\subsection{Supervisor Bad Address Register
(\texttt{sbadaddr})}\label{supervisor-bad-address-register-sbadaddr}

\texttt{sbadaddr} is an XLEN-bit read/write register. When a hardware breakpoint is triggered, or an instruction-fetch,
load, or store access exception occurs, or an instruction-fetch or AMO
address-misaligned exception occurs, \texttt{sbadaddr} is written with the
faulting address. \texttt{sbadaddr} is not modified for other exceptions.

\ifdefined\MARKDOWN
% Skip Row
\else

\begin{figure}[htb]
	{\footnotesize
		\begin{center}
			\begin{tabular}{@{}J}
				\instbitrange{XLEN-1}{0} \\
				\hline
				\multicolumn{1}{|c|}\texttt{sbadaddr} \\
				\hline
				XLEN \\
			\end{tabular}
		\end{center}
	}
	\vspace{-0.1in}
	\caption{Supervisor bad address register.}
	\label{badvaddrreg}
\end{figure}

\fi

For instruction fetch access faults on RISC-V systems with
variable-length instructions, \texttt{sbadaddr} will point to the portion of the
instruction that caused the fault while \texttt{sepc} will point to the beginning
of the instruction.

\pagebreak

\section{User Mode CSRs}\label{user-mode-csrs}

\subsection{Cycle counter for RDCYCLE instruction
(\texttt{cycle})}\label{cycle-counter-for-rdcycle-instruction-cycle}

\texttt{cycle} is an XLEN-bit read-only register. The \texttt{RDCYCLE} pseudo-instruction
reads the low XLEN bits of the \texttt{cycle} CSR that holds a count of the
number of clock cycles executed by the processor on which the hardware
thread is running from an arbitrary start time in the past.

\subsection{Instruction-retire counter for RDINSTRET instruction
(\texttt{instret})}\label{instruction-retire-counter-for-rdinstret-instruction-instret}

\texttt{instret} is an XLEN-bit read-only register. The RDINSTRET
pseudo-instruction reads the low XLEN bits of the \texttt{instret} CSR, which
counts the number of instructions retired by this hardware thread from
some arbitrary start point in the past.

\subsection{Upper 32bits of cycle (\texttt{cycleh} - RV32I
only)}\label{upper-32bits-of-cycle-cycleh---rv32i-only}

\texttt{cycleh} is a read-only register that contains bits 63-32 of the counter
of the number of clock cycles executed by the processor.

\texttt{RDCYCLEH} is an RV32I-only instruction providing access to this register.

\subsection{Upper 32bit of instret (\texttt{instreth} - RV32I
only)}\label{upper-32bit-of-instret-instreth---rv32i-only}

\texttt{instreth} is a read-only register that contains bits 63-32 of the
instruction counter.

\texttt{RDINSTRETH} is an RV32I-only instruction providing access to this
register